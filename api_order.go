/*
API2Cart OpenAPI

API2Cart

API version: 1.1
Contact: contact@api2cart.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// OrderAPIService OrderAPI service
type OrderAPIService service

type ApiOrderAbandonedListRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	start *int32
	count *int32
	pageCursor *string
	customerId *string
	customerEmail *string
	storeId *string
	createdFrom *string
	createdTo *string
	modifiedFrom *string
	modifiedTo *string
	skipEmptyEmail *bool
	responseFields *string
	params *string
	exclude *string
}

// This parameter sets the number from which you want to get entities
func (r ApiOrderAbandonedListRequest) Start(start int32) ApiOrderAbandonedListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiOrderAbandonedListRequest) Count(count int32) ApiOrderAbandonedListRequest {
	r.count = &count
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiOrderAbandonedListRequest) PageCursor(pageCursor string) ApiOrderAbandonedListRequest {
	r.pageCursor = &pageCursor
	return r
}

// Retrieves orders specified by customer id
func (r ApiOrderAbandonedListRequest) CustomerId(customerId string) ApiOrderAbandonedListRequest {
	r.customerId = &customerId
	return r
}

// Retrieves orders specified by customer email
func (r ApiOrderAbandonedListRequest) CustomerEmail(customerEmail string) ApiOrderAbandonedListRequest {
	r.customerEmail = &customerEmail
	return r
}

// Store Id
func (r ApiOrderAbandonedListRequest) StoreId(storeId string) ApiOrderAbandonedListRequest {
	r.storeId = &storeId
	return r
}

// Retrieve entities from their creation date
func (r ApiOrderAbandonedListRequest) CreatedFrom(createdFrom string) ApiOrderAbandonedListRequest {
	r.createdFrom = &createdFrom
	return r
}

// Retrieve entities to their creation date
func (r ApiOrderAbandonedListRequest) CreatedTo(createdTo string) ApiOrderAbandonedListRequest {
	r.createdTo = &createdTo
	return r
}

// Retrieve entities from their modification date
func (r ApiOrderAbandonedListRequest) ModifiedFrom(modifiedFrom string) ApiOrderAbandonedListRequest {
	r.modifiedFrom = &modifiedFrom
	return r
}

// Retrieve entities to their modification date
func (r ApiOrderAbandonedListRequest) ModifiedTo(modifiedTo string) ApiOrderAbandonedListRequest {
	r.modifiedTo = &modifiedTo
	return r
}

// Filter empty emails
func (r ApiOrderAbandonedListRequest) SkipEmptyEmail(skipEmptyEmail bool) ApiOrderAbandonedListRequest {
	r.skipEmptyEmail = &skipEmptyEmail
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderAbandonedListRequest) ResponseFields(responseFields string) ApiOrderAbandonedListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderAbandonedListRequest) Params(params string) ApiOrderAbandonedListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiOrderAbandonedListRequest) Exclude(exclude string) ApiOrderAbandonedListRequest {
	r.exclude = &exclude
	return r
}

func (r ApiOrderAbandonedListRequest) Execute() (*ModelResponseOrderAbandonedList, *http.Response, error) {
	return r.ApiService.OrderAbandonedListExecute(r)
}

/*
OrderAbandonedList order.abandoned.list

Get list of orders that were left by customers before completing the order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderAbandonedListRequest
*/
func (a *OrderAPIService) OrderAbandonedList(ctx context.Context) ApiOrderAbandonedListRequest {
	return ApiOrderAbandonedListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseOrderAbandonedList
func (a *OrderAPIService) OrderAbandonedListExecute(r ApiOrderAbandonedListRequest) (*ModelResponseOrderAbandonedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseOrderAbandonedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderAbandonedList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.abandoned.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer_id", r.customerId, "form", "")
	}
	if r.customerEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer_email", r.customerEmail, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from", r.createdFrom, "form", "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to", r.createdTo, "form", "")
	}
	if r.modifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from", r.modifiedFrom, "form", "")
	}
	if r.modifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to", r.modifiedTo, "form", "")
	}
	if r.skipEmptyEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_empty_email", r.skipEmptyEmail, "form", "")
	} else {
		var defaultValue bool = false
		r.skipEmptyEmail = &defaultValue
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "customer,totals,items"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderAddRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderAdd *OrderAdd
}

func (r ApiOrderAddRequest) OrderAdd(orderAdd OrderAdd) ApiOrderAddRequest {
	r.orderAdd = &orderAdd
	return r
}

func (r ApiOrderAddRequest) Execute() (*OrderAdd200Response, *http.Response, error) {
	return r.ApiService.OrderAddExecute(r)
}

/*
OrderAdd order.add

Add a new order to the cart.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderAddRequest
*/
func (a *OrderAPIService) OrderAdd(ctx context.Context) ApiOrderAddRequest {
	return ApiOrderAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderAdd200Response
func (a *OrderAPIService) OrderAddExecute(r ApiOrderAddRequest) (*OrderAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderAdd == nil {
		return localVarReturnValue, nil, reportError("orderAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orderAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderCalculateRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderCalculate *OrderCalculate
}

func (r ApiOrderCalculateRequest) OrderCalculate(orderCalculate OrderCalculate) ApiOrderCalculateRequest {
	r.orderCalculate = &orderCalculate
	return r
}

func (r ApiOrderCalculateRequest) Execute() (*OrderCalculate200Response, *http.Response, error) {
	return r.ApiService.OrderCalculateExecute(r)
}

/*
OrderCalculate order.calculate

<p>Calculates the total cost of an order for a given customer and a set of products, as well as the available shipping methods based on the specified address. The calculation takes into account store product prices, discounts, taxes, shipping costs, and other store settings. The result includes a detailed breakdown of the final order cost by its components.</p> <p>Note that the final totals, taxes, and other amounts must include the corresponding values for the selected shipping method.</p><p>The result of this method can be used when creating an order using the <strong>order.add</strong> method.</p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderCalculateRequest
*/
func (a *OrderAPIService) OrderCalculate(ctx context.Context) ApiOrderCalculateRequest {
	return ApiOrderCalculateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderCalculate200Response
func (a *OrderAPIService) OrderCalculateExecute(r ApiOrderCalculateRequest) (*OrderCalculate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderCalculate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderCalculate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.calculate.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderCalculate == nil {
		return localVarReturnValue, nil, reportError("orderCalculate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orderCalculate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderCountRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderIds *string
	ids *string
	customerId *string
	storeId *string
	customerEmail *string
	orderStatus *string
	orderStatusIds *[]string
	ebayOrderStatus *string
	financialStatus *string
	financialStatusIds *[]string
	fulfillmentChannel *string
	fulfillmentStatus *string
	shippingMethod *string
	deliveryMethod *string
	tags *string
	shipNodeType *string
	createdFrom *string
	createdTo *string
	modifiedFrom *string
	modifiedTo *string
}

// Counts orders specified by order ids
func (r ApiOrderCountRequest) OrderIds(orderIds string) ApiOrderCountRequest {
	r.orderIds = &orderIds
	return r
}

// Counts orders specified by ids
func (r ApiOrderCountRequest) Ids(ids string) ApiOrderCountRequest {
	r.ids = &ids
	return r
}

// Counts orders quantity specified by customer id
func (r ApiOrderCountRequest) CustomerId(customerId string) ApiOrderCountRequest {
	r.customerId = &customerId
	return r
}

// Counts orders quantity specified by store id
func (r ApiOrderCountRequest) StoreId(storeId string) ApiOrderCountRequest {
	r.storeId = &storeId
	return r
}

// Counts orders quantity specified by customer email
func (r ApiOrderCountRequest) CustomerEmail(customerEmail string) ApiOrderCountRequest {
	r.customerEmail = &customerEmail
	return r
}

// Counts orders quantity specified by order status
func (r ApiOrderCountRequest) OrderStatus(orderStatus string) ApiOrderCountRequest {
	r.orderStatus = &orderStatus
	return r
}

// Retrieves orders specified by order statuses
func (r ApiOrderCountRequest) OrderStatusIds(orderStatusIds []string) ApiOrderCountRequest {
	r.orderStatusIds = &orderStatusIds
	return r
}

// Counts orders quantity specified by order status
func (r ApiOrderCountRequest) EbayOrderStatus(ebayOrderStatus string) ApiOrderCountRequest {
	r.ebayOrderStatus = &ebayOrderStatus
	return r
}

// Counts orders quantity specified by financial status
func (r ApiOrderCountRequest) FinancialStatus(financialStatus string) ApiOrderCountRequest {
	r.financialStatus = &financialStatus
	return r
}

// Retrieves orders count specified by financial status ids
func (r ApiOrderCountRequest) FinancialStatusIds(financialStatusIds []string) ApiOrderCountRequest {
	r.financialStatusIds = &financialStatusIds
	return r
}

// Retrieves order with a fulfillment channel
func (r ApiOrderCountRequest) FulfillmentChannel(fulfillmentChannel string) ApiOrderCountRequest {
	r.fulfillmentChannel = &fulfillmentChannel
	return r
}

// Create order with fulfillment status
func (r ApiOrderCountRequest) FulfillmentStatus(fulfillmentStatus string) ApiOrderCountRequest {
	r.fulfillmentStatus = &fulfillmentStatus
	return r
}

// Retrieve entities according to shipping method
func (r ApiOrderCountRequest) ShippingMethod(shippingMethod string) ApiOrderCountRequest {
	r.shippingMethod = &shippingMethod
	return r
}

// Retrieves order with delivery method
func (r ApiOrderCountRequest) DeliveryMethod(deliveryMethod string) ApiOrderCountRequest {
	r.deliveryMethod = &deliveryMethod
	return r
}

// Order tags
func (r ApiOrderCountRequest) Tags(tags string) ApiOrderCountRequest {
	r.tags = &tags
	return r
}

// Retrieves order with ship node type
func (r ApiOrderCountRequest) ShipNodeType(shipNodeType string) ApiOrderCountRequest {
	r.shipNodeType = &shipNodeType
	return r
}

// Retrieve entities from their creation date
func (r ApiOrderCountRequest) CreatedFrom(createdFrom string) ApiOrderCountRequest {
	r.createdFrom = &createdFrom
	return r
}

// Retrieve entities to their creation date
func (r ApiOrderCountRequest) CreatedTo(createdTo string) ApiOrderCountRequest {
	r.createdTo = &createdTo
	return r
}

// Retrieve entities from their modification date
func (r ApiOrderCountRequest) ModifiedFrom(modifiedFrom string) ApiOrderCountRequest {
	r.modifiedFrom = &modifiedFrom
	return r
}

// Retrieve entities to their modification date
func (r ApiOrderCountRequest) ModifiedTo(modifiedTo string) ApiOrderCountRequest {
	r.modifiedTo = &modifiedTo
	return r
}

func (r ApiOrderCountRequest) Execute() (*OrderCount200Response, *http.Response, error) {
	return r.ApiService.OrderCountExecute(r)
}

/*
OrderCount order.count

Count orders in store

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderCountRequest
*/
func (a *OrderAPIService) OrderCount(ctx context.Context) ApiOrderCountRequest {
	return ApiOrderCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderCount200Response
func (a *OrderAPIService) OrderCountExecute(r ApiOrderCountRequest) (*OrderCount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderCount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.count.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orderIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_ids", r.orderIds, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	}
	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer_id", r.customerId, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.customerEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer_email", r.customerEmail, "form", "")
	}
	if r.orderStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_status", r.orderStatus, "form", "")
	}
	if r.orderStatusIds != nil {
		t := *r.orderStatusIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "order_status_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "order_status_ids", t, "form", "multi")
		}
	}
	if r.ebayOrderStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ebay_order_status", r.ebayOrderStatus, "form", "")
	}
	if r.financialStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "financial_status", r.financialStatus, "form", "")
	}
	if r.financialStatusIds != nil {
		t := *r.financialStatusIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "financial_status_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "financial_status_ids", t, "form", "multi")
		}
	}
	if r.fulfillmentChannel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fulfillment_channel", r.fulfillmentChannel, "form", "")
	}
	if r.fulfillmentStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fulfillment_status", r.fulfillmentStatus, "form", "")
	}
	if r.shippingMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_method", r.shippingMethod, "form", "")
	}
	if r.deliveryMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delivery_method", r.deliveryMethod, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.shipNodeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ship_node_type", r.shipNodeType, "form", "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from", r.createdFrom, "form", "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to", r.createdTo, "form", "")
	}
	if r.modifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from", r.modifiedFrom, "form", "")
	}
	if r.modifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to", r.modifiedTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderFinancialStatusListRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
}

func (r ApiOrderFinancialStatusListRequest) Execute() (*OrderFinancialStatusList200Response, *http.Response, error) {
	return r.ApiService.OrderFinancialStatusListExecute(r)
}

/*
OrderFinancialStatusList order.financial_status.list

Retrieve list of financial statuses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderFinancialStatusListRequest
*/
func (a *OrderAPIService) OrderFinancialStatusList(ctx context.Context) ApiOrderFinancialStatusListRequest {
	return ApiOrderFinancialStatusListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderFinancialStatusList200Response
func (a *OrderAPIService) OrderFinancialStatusListExecute(r ApiOrderFinancialStatusListRequest) (*OrderFinancialStatusList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderFinancialStatusList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderFinancialStatusList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.financial_status.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderFulfillmentStatusListRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	action *string
}

// Available statuses for the specified action.
func (r ApiOrderFulfillmentStatusListRequest) Action(action string) ApiOrderFulfillmentStatusListRequest {
	r.action = &action
	return r
}

func (r ApiOrderFulfillmentStatusListRequest) Execute() (*OrderFulfillmentStatusList200Response, *http.Response, error) {
	return r.ApiService.OrderFulfillmentStatusListExecute(r)
}

/*
OrderFulfillmentStatusList order.fulfillment_status.list

Retrieve list of fulfillment statuses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderFulfillmentStatusListRequest
*/
func (a *OrderAPIService) OrderFulfillmentStatusList(ctx context.Context) ApiOrderFulfillmentStatusListRequest {
	return ApiOrderFulfillmentStatusListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderFulfillmentStatusList200Response
func (a *OrderAPIService) OrderFulfillmentStatusListExecute(r ApiOrderFulfillmentStatusListRequest) (*OrderFulfillmentStatusList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderFulfillmentStatusList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderFulfillmentStatusList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.fulfillment_status.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderInfoRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	id *string
	orderId *string
	storeId *string
	params *string
	responseFields *string
	exclude *string
	enableCache *bool
	useLatestApiVersion *bool
}

// Retrieves order info specified by id
func (r ApiOrderInfoRequest) Id(id string) ApiOrderInfoRequest {
	r.id = &id
	return r
}

// Retrieves order’s info specified by order id
func (r ApiOrderInfoRequest) OrderId(orderId string) ApiOrderInfoRequest {
	r.orderId = &orderId
	return r
}

// Defines store id where the order should be found
func (r ApiOrderInfoRequest) StoreId(storeId string) ApiOrderInfoRequest {
	r.storeId = &storeId
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderInfoRequest) Params(params string) ApiOrderInfoRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderInfoRequest) ResponseFields(responseFields string) ApiOrderInfoRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiOrderInfoRequest) Exclude(exclude string) ApiOrderInfoRequest {
	r.exclude = &exclude
	return r
}

// If the value is &#39;true&#39; and order exist in our cache, we will return order.info response from cache
func (r ApiOrderInfoRequest) EnableCache(enableCache bool) ApiOrderInfoRequest {
	r.enableCache = &enableCache
	return r
}

// Use the latest platform API version
func (r ApiOrderInfoRequest) UseLatestApiVersion(useLatestApiVersion bool) ApiOrderInfoRequest {
	r.useLatestApiVersion = &useLatestApiVersion
	return r
}

func (r ApiOrderInfoRequest) Execute() (*OrderInfo200Response, *http.Response, error) {
	return r.ApiService.OrderInfoExecute(r)
}

/*
OrderInfo order.info

Info about a specific order by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderInfoRequest
*/
func (a *OrderAPIService) OrderInfo(ctx context.Context) ApiOrderInfoRequest {
	return ApiOrderInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderInfo200Response
func (a *OrderAPIService) OrderInfoExecute(r ApiOrderInfoRequest) (*OrderInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.info.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_id", r.orderId, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "order_id,customer,totals,address,items,bundles,status"
		r.params = &defaultValue
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.enableCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enable_cache", r.enableCache, "form", "")
	} else {
		var defaultValue bool = false
		r.enableCache = &defaultValue
	}
	if r.useLatestApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_latest_api_version", r.useLatestApiVersion, "form", "")
	} else {
		var defaultValue bool = false
		r.useLatestApiVersion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderListRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	start *int32
	count *int32
	pageCursor *string
	ids *string
	orderIds *string
	sinceId *string
	storeId *string
	customerId *string
	customerEmail *string
	basketId *string
	currencyId *string
	phone *string
	orderStatus *string
	orderStatusIds *[]string
	ebayOrderStatus *string
	financialStatus *string
	financialStatusIds *[]string
	fulfillmentStatus *string
	returnStatus *string
	fulfillmentChannel *string
	shippingMethod *string
	skipOrderIds *string
	isDeleted *bool
	shippingCountryIso3 *string
	deliveryMethod *string
	shipNodeType *string
	createdTo *string
	createdFrom *string
	modifiedTo *string
	modifiedFrom *string
	tags *string
	sortBy *string
	sortDirection *string
	params *string
	responseFields *string
	exclude *string
	enableCache *bool
	useLatestApiVersion *bool
}

// This parameter sets the number from which you want to get entities
func (r ApiOrderListRequest) Start(start int32) ApiOrderListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiOrderListRequest) Count(count int32) ApiOrderListRequest {
	r.count = &count
	return r
}

// Used to retrieve orders via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiOrderListRequest) PageCursor(pageCursor string) ApiOrderListRequest {
	r.pageCursor = &pageCursor
	return r
}

// Retrieves orders specified by ids
func (r ApiOrderListRequest) Ids(ids string) ApiOrderListRequest {
	r.ids = &ids
	return r
}

// Retrieves orders specified by order ids
func (r ApiOrderListRequest) OrderIds(orderIds string) ApiOrderListRequest {
	r.orderIds = &orderIds
	return r
}

// Retrieve entities starting from the specified id.
func (r ApiOrderListRequest) SinceId(sinceId string) ApiOrderListRequest {
	r.sinceId = &sinceId
	return r
}

// Store Id
func (r ApiOrderListRequest) StoreId(storeId string) ApiOrderListRequest {
	r.storeId = &storeId
	return r
}

// Retrieves orders specified by customer id
func (r ApiOrderListRequest) CustomerId(customerId string) ApiOrderListRequest {
	r.customerId = &customerId
	return r
}

// Retrieves orders specified by customer email
func (r ApiOrderListRequest) CustomerEmail(customerEmail string) ApiOrderListRequest {
	r.customerEmail = &customerEmail
	return r
}

// Retrieves order’s info specified by basket id.
func (r ApiOrderListRequest) BasketId(basketId string) ApiOrderListRequest {
	r.basketId = &basketId
	return r
}

// Currency Id
func (r ApiOrderListRequest) CurrencyId(currencyId string) ApiOrderListRequest {
	r.currencyId = &currencyId
	return r
}

// Filter orders by customer&#39;s phone number
func (r ApiOrderListRequest) Phone(phone string) ApiOrderListRequest {
	r.phone = &phone
	return r
}

// Retrieves orders specified by order status
func (r ApiOrderListRequest) OrderStatus(orderStatus string) ApiOrderListRequest {
	r.orderStatus = &orderStatus
	return r
}

// Retrieves orders specified by order statuses
func (r ApiOrderListRequest) OrderStatusIds(orderStatusIds []string) ApiOrderListRequest {
	r.orderStatusIds = &orderStatusIds
	return r
}

// Retrieves orders specified by order status
func (r ApiOrderListRequest) EbayOrderStatus(ebayOrderStatus string) ApiOrderListRequest {
	r.ebayOrderStatus = &ebayOrderStatus
	return r
}

// Retrieves orders specified by financial status
func (r ApiOrderListRequest) FinancialStatus(financialStatus string) ApiOrderListRequest {
	r.financialStatus = &financialStatus
	return r
}

// Retrieves orders specified by financial status ids
func (r ApiOrderListRequest) FinancialStatusIds(financialStatusIds []string) ApiOrderListRequest {
	r.financialStatusIds = &financialStatusIds
	return r
}

// Create order with fulfillment status
func (r ApiOrderListRequest) FulfillmentStatus(fulfillmentStatus string) ApiOrderListRequest {
	r.fulfillmentStatus = &fulfillmentStatus
	return r
}

// Retrieves orders specified by return status
func (r ApiOrderListRequest) ReturnStatus(returnStatus string) ApiOrderListRequest {
	r.returnStatus = &returnStatus
	return r
}

// Retrieves order with a fulfillment channel
func (r ApiOrderListRequest) FulfillmentChannel(fulfillmentChannel string) ApiOrderListRequest {
	r.fulfillmentChannel = &fulfillmentChannel
	return r
}

// Retrieve entities according to shipping method
func (r ApiOrderListRequest) ShippingMethod(shippingMethod string) ApiOrderListRequest {
	r.shippingMethod = &shippingMethod
	return r
}

// Skipped orders by ids
func (r ApiOrderListRequest) SkipOrderIds(skipOrderIds string) ApiOrderListRequest {
	r.skipOrderIds = &skipOrderIds
	return r
}

// Filter deleted orders
func (r ApiOrderListRequest) IsDeleted(isDeleted bool) ApiOrderListRequest {
	r.isDeleted = &isDeleted
	return r
}

// Retrieve entities according to shipping country
func (r ApiOrderListRequest) ShippingCountryIso3(shippingCountryIso3 string) ApiOrderListRequest {
	r.shippingCountryIso3 = &shippingCountryIso3
	return r
}

// Retrieves order with delivery method
func (r ApiOrderListRequest) DeliveryMethod(deliveryMethod string) ApiOrderListRequest {
	r.deliveryMethod = &deliveryMethod
	return r
}

// Retrieves order with ship node type
func (r ApiOrderListRequest) ShipNodeType(shipNodeType string) ApiOrderListRequest {
	r.shipNodeType = &shipNodeType
	return r
}

// Retrieve entities to their creation date
func (r ApiOrderListRequest) CreatedTo(createdTo string) ApiOrderListRequest {
	r.createdTo = &createdTo
	return r
}

// Retrieve entities from their creation date
func (r ApiOrderListRequest) CreatedFrom(createdFrom string) ApiOrderListRequest {
	r.createdFrom = &createdFrom
	return r
}

// Retrieve entities to their modification date
func (r ApiOrderListRequest) ModifiedTo(modifiedTo string) ApiOrderListRequest {
	r.modifiedTo = &modifiedTo
	return r
}

// Retrieve entities from their modification date
func (r ApiOrderListRequest) ModifiedFrom(modifiedFrom string) ApiOrderListRequest {
	r.modifiedFrom = &modifiedFrom
	return r
}

// Order tags
func (r ApiOrderListRequest) Tags(tags string) ApiOrderListRequest {
	r.tags = &tags
	return r
}

// Set field to sort by
func (r ApiOrderListRequest) SortBy(sortBy string) ApiOrderListRequest {
	r.sortBy = &sortBy
	return r
}

// Set sorting direction
func (r ApiOrderListRequest) SortDirection(sortDirection string) ApiOrderListRequest {
	r.sortDirection = &sortDirection
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderListRequest) Params(params string) ApiOrderListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderListRequest) ResponseFields(responseFields string) ApiOrderListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiOrderListRequest) Exclude(exclude string) ApiOrderListRequest {
	r.exclude = &exclude
	return r
}

// If the value is &#39;true&#39;, we will cache orders for a 15 minutes in order to increase speed and reduce requests throttling for some methods and shoping platforms (for example order.shipment.add)
func (r ApiOrderListRequest) EnableCache(enableCache bool) ApiOrderListRequest {
	r.enableCache = &enableCache
	return r
}

// Use the latest platform API version
func (r ApiOrderListRequest) UseLatestApiVersion(useLatestApiVersion bool) ApiOrderListRequest {
	r.useLatestApiVersion = &useLatestApiVersion
	return r
}

func (r ApiOrderListRequest) Execute() (*ModelResponseOrderList, *http.Response, error) {
	return r.ApiService.OrderListExecute(r)
}

/*
OrderList order.list

Get list of orders from store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderListRequest
*/
func (a *OrderAPIService) OrderList(ctx context.Context) ApiOrderListRequest {
	return ApiOrderListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseOrderList
func (a *OrderAPIService) OrderListExecute(r ApiOrderListRequest) (*ModelResponseOrderList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseOrderList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	}
	if r.orderIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_ids", r.orderIds, "form", "")
	}
	if r.sinceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_id", r.sinceId, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer_id", r.customerId, "form", "")
	}
	if r.customerEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer_email", r.customerEmail, "form", "")
	}
	if r.basketId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "basket_id", r.basketId, "form", "")
	}
	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency_id", r.currencyId, "form", "")
	}
	if r.phone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "phone", r.phone, "form", "")
	}
	if r.orderStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_status", r.orderStatus, "form", "")
	}
	if r.orderStatusIds != nil {
		t := *r.orderStatusIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "order_status_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "order_status_ids", t, "form", "multi")
		}
	}
	if r.ebayOrderStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ebay_order_status", r.ebayOrderStatus, "form", "")
	}
	if r.financialStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "financial_status", r.financialStatus, "form", "")
	}
	if r.financialStatusIds != nil {
		t := *r.financialStatusIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "financial_status_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "financial_status_ids", t, "form", "multi")
		}
	}
	if r.fulfillmentStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fulfillment_status", r.fulfillmentStatus, "form", "")
	}
	if r.returnStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "return_status", r.returnStatus, "form", "")
	}
	if r.fulfillmentChannel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fulfillment_channel", r.fulfillmentChannel, "form", "")
	}
	if r.shippingMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_method", r.shippingMethod, "form", "")
	}
	if r.skipOrderIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_order_ids", r.skipOrderIds, "form", "")
	}
	if r.isDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_deleted", r.isDeleted, "form", "")
	}
	if r.shippingCountryIso3 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shipping_country_iso3", r.shippingCountryIso3, "form", "")
	}
	if r.deliveryMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delivery_method", r.deliveryMethod, "form", "")
	}
	if r.shipNodeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ship_node_type", r.shipNodeType, "form", "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to", r.createdTo, "form", "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from", r.createdFrom, "form", "")
	}
	if r.modifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to", r.modifiedTo, "form", "")
	}
	if r.modifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from", r.modifiedFrom, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	} else {
		var defaultValue string = "order_id"
		r.sortBy = &defaultValue
	}
	if r.sortDirection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_direction", r.sortDirection, "form", "")
	} else {
		var defaultValue string = "asc"
		r.sortDirection = &defaultValue
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "order_id,customer,totals,address,items,bundles,status"
		r.params = &defaultValue
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.enableCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enable_cache", r.enableCache, "form", "")
	} else {
		var defaultValue bool = false
		r.enableCache = &defaultValue
	}
	if r.useLatestApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_latest_api_version", r.useLatestApiVersion, "form", "")
	} else {
		var defaultValue bool = false
		r.useLatestApiVersion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderPreestimateShippingListRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderPreestimateShippingList *OrderPreestimateShippingList
}

func (r ApiOrderPreestimateShippingListRequest) OrderPreestimateShippingList(orderPreestimateShippingList OrderPreestimateShippingList) ApiOrderPreestimateShippingListRequest {
	r.orderPreestimateShippingList = &orderPreestimateShippingList
	return r
}

func (r ApiOrderPreestimateShippingListRequest) Execute() (*ModelResponseOrderPreestimateShippingList, *http.Response, error) {
	return r.ApiService.OrderPreestimateShippingListExecute(r)
}

/*
OrderPreestimateShippingList order.preestimate_shipping.list

Retrieve list of order preestimated shipping methods

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderPreestimateShippingListRequest
*/
func (a *OrderAPIService) OrderPreestimateShippingList(ctx context.Context) ApiOrderPreestimateShippingListRequest {
	return ApiOrderPreestimateShippingListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseOrderPreestimateShippingList
func (a *OrderAPIService) OrderPreestimateShippingListExecute(r ApiOrderPreestimateShippingListRequest) (*ModelResponseOrderPreestimateShippingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseOrderPreestimateShippingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderPreestimateShippingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.preestimate_shipping.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderPreestimateShippingList == nil {
		return localVarReturnValue, nil, reportError("orderPreestimateShippingList is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orderPreestimateShippingList
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderRefundAddRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderRefundAdd *OrderRefundAdd
}

func (r ApiOrderRefundAddRequest) OrderRefundAdd(orderRefundAdd OrderRefundAdd) ApiOrderRefundAddRequest {
	r.orderRefundAdd = &orderRefundAdd
	return r
}

func (r ApiOrderRefundAddRequest) Execute() (*OrderRefundAdd200Response, *http.Response, error) {
	return r.ApiService.OrderRefundAddExecute(r)
}

/*
OrderRefundAdd order.refund.add

Add a refund to the order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderRefundAddRequest
*/
func (a *OrderAPIService) OrderRefundAdd(ctx context.Context) ApiOrderRefundAddRequest {
	return ApiOrderRefundAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderRefundAdd200Response
func (a *OrderAPIService) OrderRefundAddExecute(r ApiOrderRefundAddRequest) (*OrderRefundAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderRefundAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderRefundAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.refund.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderRefundAdd == nil {
		return localVarReturnValue, nil, reportError("orderRefundAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orderRefundAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderReturnAddRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderReturnAdd *OrderReturnAdd
}

func (r ApiOrderReturnAddRequest) OrderReturnAdd(orderReturnAdd OrderReturnAdd) ApiOrderReturnAddRequest {
	r.orderReturnAdd = &orderReturnAdd
	return r
}

func (r ApiOrderReturnAddRequest) Execute() (*OrderReturnAdd200Response, *http.Response, error) {
	return r.ApiService.OrderReturnAddExecute(r)
}

/*
OrderReturnAdd order.return.add

Create new return request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderReturnAddRequest
*/
func (a *OrderAPIService) OrderReturnAdd(ctx context.Context) ApiOrderReturnAddRequest {
	return ApiOrderReturnAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderReturnAdd200Response
func (a *OrderAPIService) OrderReturnAddExecute(r ApiOrderReturnAddRequest) (*OrderReturnAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderReturnAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderReturnAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.return.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderReturnAdd == nil {
		return localVarReturnValue, nil, reportError("orderReturnAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orderReturnAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderReturnDeleteRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	returnId *string
	orderId *string
	storeId *string
}

// Return ID
func (r ApiOrderReturnDeleteRequest) ReturnId(returnId string) ApiOrderReturnDeleteRequest {
	r.returnId = &returnId
	return r
}

// Defines the order id
func (r ApiOrderReturnDeleteRequest) OrderId(orderId string) ApiOrderReturnDeleteRequest {
	r.orderId = &orderId
	return r
}

// Store Id
func (r ApiOrderReturnDeleteRequest) StoreId(storeId string) ApiOrderReturnDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiOrderReturnDeleteRequest) Execute() (*AttributeValueDelete200Response, *http.Response, error) {
	return r.ApiService.OrderReturnDeleteExecute(r)
}

/*
OrderReturnDelete order.return.delete

Delete return.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderReturnDeleteRequest
*/
func (a *OrderAPIService) OrderReturnDelete(ctx context.Context) ApiOrderReturnDeleteRequest {
	return ApiOrderReturnDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeValueDelete200Response
func (a *OrderAPIService) OrderReturnDeleteExecute(r ApiOrderReturnDeleteRequest) (*AttributeValueDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeValueDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderReturnDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.return.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnId == nil {
		return localVarReturnValue, nil, reportError("returnId is required and must be specified")
	}
	if r.orderId == nil {
		return localVarReturnValue, nil, reportError("orderId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "return_id", r.returnId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "order_id", r.orderId, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderReturnUpdateRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderReturnUpdate *OrderReturnUpdate
}

func (r ApiOrderReturnUpdateRequest) OrderReturnUpdate(orderReturnUpdate OrderReturnUpdate) ApiOrderReturnUpdateRequest {
	r.orderReturnUpdate = &orderReturnUpdate
	return r
}

func (r ApiOrderReturnUpdateRequest) Execute() (*AccountConfigUpdate200Response, *http.Response, error) {
	return r.ApiService.OrderReturnUpdateExecute(r)
}

/*
OrderReturnUpdate order.return.update

Update order's shipment information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderReturnUpdateRequest
*/
func (a *OrderAPIService) OrderReturnUpdate(ctx context.Context) ApiOrderReturnUpdateRequest {
	return ApiOrderReturnUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountConfigUpdate200Response
func (a *OrderAPIService) OrderReturnUpdateExecute(r ApiOrderReturnUpdateRequest) (*AccountConfigUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountConfigUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderReturnUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.return.update.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderReturnUpdate == nil {
		return localVarReturnValue, nil, reportError("orderReturnUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orderReturnUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderShipmentAddRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderShipmentAdd *OrderShipmentAdd
}

func (r ApiOrderShipmentAddRequest) OrderShipmentAdd(orderShipmentAdd OrderShipmentAdd) ApiOrderShipmentAddRequest {
	r.orderShipmentAdd = &orderShipmentAdd
	return r
}

func (r ApiOrderShipmentAddRequest) Execute() (*OrderShipmentAdd200Response, *http.Response, error) {
	return r.ApiService.OrderShipmentAddExecute(r)
}

/*
OrderShipmentAdd order.shipment.add

Add a shipment to the order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderShipmentAddRequest
*/
func (a *OrderAPIService) OrderShipmentAdd(ctx context.Context) ApiOrderShipmentAddRequest {
	return ApiOrderShipmentAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderShipmentAdd200Response
func (a *OrderAPIService) OrderShipmentAddExecute(r ApiOrderShipmentAddRequest) (*OrderShipmentAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderShipmentAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderShipmentAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.shipment.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderShipmentAdd == nil {
		return localVarReturnValue, nil, reportError("orderShipmentAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orderShipmentAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderShipmentAddBatchRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderShipmentAddBatch *OrderShipmentAddBatch
}

func (r ApiOrderShipmentAddBatchRequest) OrderShipmentAddBatch(orderShipmentAddBatch OrderShipmentAddBatch) ApiOrderShipmentAddBatchRequest {
	r.orderShipmentAddBatch = &orderShipmentAddBatch
	return r
}

func (r ApiOrderShipmentAddBatchRequest) Execute() (*CategoryAddBatch200Response, *http.Response, error) {
	return r.ApiService.OrderShipmentAddBatchExecute(r)
}

/*
OrderShipmentAddBatch order.shipment.add.batch

Add a shipments to the orders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderShipmentAddBatchRequest
*/
func (a *OrderAPIService) OrderShipmentAddBatch(ctx context.Context) ApiOrderShipmentAddBatchRequest {
	return ApiOrderShipmentAddBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CategoryAddBatch200Response
func (a *OrderAPIService) OrderShipmentAddBatchExecute(r ApiOrderShipmentAddBatchRequest) (*CategoryAddBatch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryAddBatch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderShipmentAddBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.shipment.add.batch.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderShipmentAddBatch == nil {
		return localVarReturnValue, nil, reportError("orderShipmentAddBatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orderShipmentAddBatch
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderShipmentDeleteRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	shipmentId *string
	orderId *string
	storeId *string
}

// Shipment id indicates the number of delivery
func (r ApiOrderShipmentDeleteRequest) ShipmentId(shipmentId string) ApiOrderShipmentDeleteRequest {
	r.shipmentId = &shipmentId
	return r
}

// Defines the order for which the shipment will be deleted
func (r ApiOrderShipmentDeleteRequest) OrderId(orderId string) ApiOrderShipmentDeleteRequest {
	r.orderId = &orderId
	return r
}

// Store Id
func (r ApiOrderShipmentDeleteRequest) StoreId(storeId string) ApiOrderShipmentDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiOrderShipmentDeleteRequest) Execute() (*OrderShipmentDelete200Response, *http.Response, error) {
	return r.ApiService.OrderShipmentDeleteExecute(r)
}

/*
OrderShipmentDelete order.shipment.delete

Delete order's shipment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderShipmentDeleteRequest
*/
func (a *OrderAPIService) OrderShipmentDelete(ctx context.Context) ApiOrderShipmentDeleteRequest {
	return ApiOrderShipmentDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderShipmentDelete200Response
func (a *OrderAPIService) OrderShipmentDeleteExecute(r ApiOrderShipmentDeleteRequest) (*OrderShipmentDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderShipmentDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderShipmentDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.shipment.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shipmentId == nil {
		return localVarReturnValue, nil, reportError("shipmentId is required and must be specified")
	}
	if r.orderId == nil {
		return localVarReturnValue, nil, reportError("orderId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shipment_id", r.shipmentId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "order_id", r.orderId, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderShipmentInfoRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	id *string
	orderId *string
	start *int32
	storeId *string
	responseFields *string
	params *string
	exclude *string
}

// Entity id
func (r ApiOrderShipmentInfoRequest) Id(id string) ApiOrderShipmentInfoRequest {
	r.id = &id
	return r
}

// Defines the order id
func (r ApiOrderShipmentInfoRequest) OrderId(orderId string) ApiOrderShipmentInfoRequest {
	r.orderId = &orderId
	return r
}

// This parameter sets the number from which you want to get entities
func (r ApiOrderShipmentInfoRequest) Start(start int32) ApiOrderShipmentInfoRequest {
	r.start = &start
	return r
}

// Store Id
func (r ApiOrderShipmentInfoRequest) StoreId(storeId string) ApiOrderShipmentInfoRequest {
	r.storeId = &storeId
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderShipmentInfoRequest) ResponseFields(responseFields string) ApiOrderShipmentInfoRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderShipmentInfoRequest) Params(params string) ApiOrderShipmentInfoRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiOrderShipmentInfoRequest) Exclude(exclude string) ApiOrderShipmentInfoRequest {
	r.exclude = &exclude
	return r
}

func (r ApiOrderShipmentInfoRequest) Execute() (*OrderShipmentInfo200Response, *http.Response, error) {
	return r.ApiService.OrderShipmentInfoExecute(r)
}

/*
OrderShipmentInfo order.shipment.info

Get information of shipment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderShipmentInfoRequest
*/
func (a *OrderAPIService) OrderShipmentInfo(ctx context.Context) ApiOrderShipmentInfoRequest {
	return ApiOrderShipmentInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderShipmentInfo200Response
func (a *OrderAPIService) OrderShipmentInfoExecute(r ApiOrderShipmentInfoRequest) (*OrderShipmentInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderShipmentInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderShipmentInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.shipment.info.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.orderId == nil {
		return localVarReturnValue, nil, reportError("orderId is required and must be specified")
	}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "order_id", r.orderId, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,order_id,items,tracking_numbers"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderShipmentListRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderId *string
	start *int32
	count *int32
	pageCursor *string
	storeId *string
	createdFrom *string
	createdTo *string
	modifiedFrom *string
	modifiedTo *string
	responseFields *string
	params *string
	exclude *string
}

// Retrieves shipments specified by order id
func (r ApiOrderShipmentListRequest) OrderId(orderId string) ApiOrderShipmentListRequest {
	r.orderId = &orderId
	return r
}

// This parameter sets the number from which you want to get entities
func (r ApiOrderShipmentListRequest) Start(start int32) ApiOrderShipmentListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiOrderShipmentListRequest) Count(count int32) ApiOrderShipmentListRequest {
	r.count = &count
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiOrderShipmentListRequest) PageCursor(pageCursor string) ApiOrderShipmentListRequest {
	r.pageCursor = &pageCursor
	return r
}

// Store Id
func (r ApiOrderShipmentListRequest) StoreId(storeId string) ApiOrderShipmentListRequest {
	r.storeId = &storeId
	return r
}

// Retrieve entities from their creation date
func (r ApiOrderShipmentListRequest) CreatedFrom(createdFrom string) ApiOrderShipmentListRequest {
	r.createdFrom = &createdFrom
	return r
}

// Retrieve entities to their creation date
func (r ApiOrderShipmentListRequest) CreatedTo(createdTo string) ApiOrderShipmentListRequest {
	r.createdTo = &createdTo
	return r
}

// Retrieve entities from their modification date
func (r ApiOrderShipmentListRequest) ModifiedFrom(modifiedFrom string) ApiOrderShipmentListRequest {
	r.modifiedFrom = &modifiedFrom
	return r
}

// Retrieve entities to their modification date
func (r ApiOrderShipmentListRequest) ModifiedTo(modifiedTo string) ApiOrderShipmentListRequest {
	r.modifiedTo = &modifiedTo
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderShipmentListRequest) ResponseFields(responseFields string) ApiOrderShipmentListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderShipmentListRequest) Params(params string) ApiOrderShipmentListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiOrderShipmentListRequest) Exclude(exclude string) ApiOrderShipmentListRequest {
	r.exclude = &exclude
	return r
}

func (r ApiOrderShipmentListRequest) Execute() (*ModelResponseOrderShipmentList, *http.Response, error) {
	return r.ApiService.OrderShipmentListExecute(r)
}

/*
OrderShipmentList order.shipment.list

Get list of shipments per order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderShipmentListRequest
*/
func (a *OrderAPIService) OrderShipmentList(ctx context.Context) ApiOrderShipmentListRequest {
	return ApiOrderShipmentListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseOrderShipmentList
func (a *OrderAPIService) OrderShipmentListExecute(r ApiOrderShipmentListRequest) (*ModelResponseOrderShipmentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseOrderShipmentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderShipmentList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.shipment.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderId == nil {
		return localVarReturnValue, nil, reportError("orderId is required and must be specified")
	}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "order_id", r.orderId, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from", r.createdFrom, "form", "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to", r.createdTo, "form", "")
	}
	if r.modifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from", r.modifiedFrom, "form", "")
	}
	if r.modifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to", r.modifiedTo, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,order_id,items,tracking_numbers"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderShipmentTrackingAddRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderShipmentTrackingAdd *OrderShipmentTrackingAdd
}

func (r ApiOrderShipmentTrackingAddRequest) OrderShipmentTrackingAdd(orderShipmentTrackingAdd OrderShipmentTrackingAdd) ApiOrderShipmentTrackingAddRequest {
	r.orderShipmentTrackingAdd = &orderShipmentTrackingAdd
	return r
}

func (r ApiOrderShipmentTrackingAddRequest) Execute() (*OrderShipmentTrackingAdd200Response, *http.Response, error) {
	return r.ApiService.OrderShipmentTrackingAddExecute(r)
}

/*
OrderShipmentTrackingAdd order.shipment.tracking.add

Add order shipment's tracking info.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderShipmentTrackingAddRequest
*/
func (a *OrderAPIService) OrderShipmentTrackingAdd(ctx context.Context) ApiOrderShipmentTrackingAddRequest {
	return ApiOrderShipmentTrackingAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderShipmentTrackingAdd200Response
func (a *OrderAPIService) OrderShipmentTrackingAddExecute(r ApiOrderShipmentTrackingAddRequest) (*OrderShipmentTrackingAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderShipmentTrackingAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderShipmentTrackingAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.shipment.tracking.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderShipmentTrackingAdd == nil {
		return localVarReturnValue, nil, reportError("orderShipmentTrackingAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orderShipmentTrackingAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderShipmentUpdateRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderShipmentUpdate *OrderShipmentUpdate
}

func (r ApiOrderShipmentUpdateRequest) OrderShipmentUpdate(orderShipmentUpdate OrderShipmentUpdate) ApiOrderShipmentUpdateRequest {
	r.orderShipmentUpdate = &orderShipmentUpdate
	return r
}

func (r ApiOrderShipmentUpdateRequest) Execute() (*AccountConfigUpdate200Response, *http.Response, error) {
	return r.ApiService.OrderShipmentUpdateExecute(r)
}

/*
OrderShipmentUpdate order.shipment.update

Update order's shipment information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderShipmentUpdateRequest
*/
func (a *OrderAPIService) OrderShipmentUpdate(ctx context.Context) ApiOrderShipmentUpdateRequest {
	return ApiOrderShipmentUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountConfigUpdate200Response
func (a *OrderAPIService) OrderShipmentUpdateExecute(r ApiOrderShipmentUpdateRequest) (*AccountConfigUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountConfigUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderShipmentUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.shipment.update.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderShipmentUpdate == nil {
		return localVarReturnValue, nil, reportError("orderShipmentUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.orderShipmentUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderStatusListRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	storeId *string
	action *string
	responseFields *string
}

// Store Id
func (r ApiOrderStatusListRequest) StoreId(storeId string) ApiOrderStatusListRequest {
	r.storeId = &storeId
	return r
}

// Available statuses for the specified action.
func (r ApiOrderStatusListRequest) Action(action string) ApiOrderStatusListRequest {
	r.action = &action
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderStatusListRequest) ResponseFields(responseFields string) ApiOrderStatusListRequest {
	r.responseFields = &responseFields
	return r
}

func (r ApiOrderStatusListRequest) Execute() (*ModelResponseOrderStatusList, *http.Response, error) {
	return r.ApiService.OrderStatusListExecute(r)
}

/*
OrderStatusList order.status.list

Retrieve list of statuses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderStatusListRequest
*/
func (a *OrderAPIService) OrderStatusList(ctx context.Context) ApiOrderStatusListRequest {
	return ApiOrderStatusListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseOrderStatusList
func (a *OrderAPIService) OrderStatusListExecute(r ApiOrderStatusListRequest) (*ModelResponseOrderStatusList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseOrderStatusList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderStatusList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.status.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderTransactionListRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderIds *string
	count *int32
	pageCursor *string
	storeId *string
	params *string
	responseFields *string
	exclude *string
}

// Retrieves order transactions specified by order ids
func (r ApiOrderTransactionListRequest) OrderIds(orderIds string) ApiOrderTransactionListRequest {
	r.orderIds = &orderIds
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiOrderTransactionListRequest) Count(count int32) ApiOrderTransactionListRequest {
	r.count = &count
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiOrderTransactionListRequest) PageCursor(pageCursor string) ApiOrderTransactionListRequest {
	r.pageCursor = &pageCursor
	return r
}

// Store Id
func (r ApiOrderTransactionListRequest) StoreId(storeId string) ApiOrderTransactionListRequest {
	r.storeId = &storeId
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderTransactionListRequest) Params(params string) ApiOrderTransactionListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiOrderTransactionListRequest) ResponseFields(responseFields string) ApiOrderTransactionListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiOrderTransactionListRequest) Exclude(exclude string) ApiOrderTransactionListRequest {
	r.exclude = &exclude
	return r
}

func (r ApiOrderTransactionListRequest) Execute() (*ModelResponseOrderTransactionList, *http.Response, error) {
	return r.ApiService.OrderTransactionListExecute(r)
}

/*
OrderTransactionList order.transaction.list

Retrieve list of order transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderTransactionListRequest
*/
func (a *OrderAPIService) OrderTransactionList(ctx context.Context) ApiOrderTransactionListRequest {
	return ApiOrderTransactionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseOrderTransactionList
func (a *OrderAPIService) OrderTransactionListExecute(r ApiOrderTransactionListRequest) (*ModelResponseOrderTransactionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseOrderTransactionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderTransactionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.transaction.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderIds == nil {
		return localVarReturnValue, nil, reportError("orderIds is required and must be specified")
	}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "order_ids", r.orderIds, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,order_id,amount,description"
		r.params = &defaultValue
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderUpdateRequest struct {
	ctx context.Context
	ApiService *OrderAPIService
	orderId *string
	storeId *string
	orderStatus *string
	financialStatus *string
	fulfillmentStatus *string
	cancellationReason *string
	orderPaymentMethod *string
	comment *string
	adminComment *string
	adminPrivateComment *string
	invoiceAdminComment *string
	dateModified *string
	dateFinished *string
	sendNotifications *bool
	createInvoice *bool
	origin *string
	tags *string
}

// Defines the orders specified by order id
func (r ApiOrderUpdateRequest) OrderId(orderId string) ApiOrderUpdateRequest {
	r.orderId = &orderId
	return r
}

// Defines store id where the order should be found
func (r ApiOrderUpdateRequest) StoreId(storeId string) ApiOrderUpdateRequest {
	r.storeId = &storeId
	return r
}

// Defines new order&#39;s status
func (r ApiOrderUpdateRequest) OrderStatus(orderStatus string) ApiOrderUpdateRequest {
	r.orderStatus = &orderStatus
	return r
}

// Update order financial status to specified
func (r ApiOrderUpdateRequest) FinancialStatus(financialStatus string) ApiOrderUpdateRequest {
	r.financialStatus = &financialStatus
	return r
}

// Create order with fulfillment status
func (r ApiOrderUpdateRequest) FulfillmentStatus(fulfillmentStatus string) ApiOrderUpdateRequest {
	r.fulfillmentStatus = &fulfillmentStatus
	return r
}

// Defines the cancellation reason when the order will be canceled
func (r ApiOrderUpdateRequest) CancellationReason(cancellationReason string) ApiOrderUpdateRequest {
	r.cancellationReason = &cancellationReason
	return r
}

// Defines order payment method.&lt;br/&gt;Setting order_payment_method on Shopify will also change financial_status field value to &#39;paid&#39;
func (r ApiOrderUpdateRequest) OrderPaymentMethod(orderPaymentMethod string) ApiOrderUpdateRequest {
	r.orderPaymentMethod = &orderPaymentMethod
	return r
}

// Specifies order comment
func (r ApiOrderUpdateRequest) Comment(comment string) ApiOrderUpdateRequest {
	r.comment = &comment
	return r
}

// Specifies admin&#39;s order comment
func (r ApiOrderUpdateRequest) AdminComment(adminComment string) ApiOrderUpdateRequest {
	r.adminComment = &adminComment
	return r
}

// Specifies private admin&#39;s order comment
func (r ApiOrderUpdateRequest) AdminPrivateComment(adminPrivateComment string) ApiOrderUpdateRequest {
	r.adminPrivateComment = &adminPrivateComment
	return r
}

// Specifies admin&#39;s order invoice comment
func (r ApiOrderUpdateRequest) InvoiceAdminComment(invoiceAdminComment string) ApiOrderUpdateRequest {
	r.invoiceAdminComment = &invoiceAdminComment
	return r
}

// Specifies order&#39;s  modification date
func (r ApiOrderUpdateRequest) DateModified(dateModified string) ApiOrderUpdateRequest {
	r.dateModified = &dateModified
	return r
}

// Specifies order&#39;s  finished date
func (r ApiOrderUpdateRequest) DateFinished(dateFinished string) ApiOrderUpdateRequest {
	r.dateFinished = &dateFinished
	return r
}

// Send notifications to customer after order was created
func (r ApiOrderUpdateRequest) SendNotifications(sendNotifications bool) ApiOrderUpdateRequest {
	r.sendNotifications = &sendNotifications
	return r
}

// Determines whether an invoice should be created if it has not already been created
func (r ApiOrderUpdateRequest) CreateInvoice(createInvoice bool) ApiOrderUpdateRequest {
	r.createInvoice = &createInvoice
	return r
}

// The source of the order
func (r ApiOrderUpdateRequest) Origin(origin string) ApiOrderUpdateRequest {
	r.origin = &origin
	return r
}

// Order tags
func (r ApiOrderUpdateRequest) Tags(tags string) ApiOrderUpdateRequest {
	r.tags = &tags
	return r
}

func (r ApiOrderUpdateRequest) Execute() (*AccountConfigUpdate200Response, *http.Response, error) {
	return r.ApiService.OrderUpdateExecute(r)
}

/*
OrderUpdate order.update

Update existing order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderUpdateRequest
*/
func (a *OrderAPIService) OrderUpdate(ctx context.Context) ApiOrderUpdateRequest {
	return ApiOrderUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountConfigUpdate200Response
func (a *OrderAPIService) OrderUpdateExecute(r ApiOrderUpdateRequest) (*AccountConfigUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountConfigUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrderAPIService.OrderUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/order.update.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderId == nil {
		return localVarReturnValue, nil, reportError("orderId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "order_id", r.orderId, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.orderStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_status", r.orderStatus, "form", "")
	}
	if r.financialStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "financial_status", r.financialStatus, "form", "")
	}
	if r.fulfillmentStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fulfillment_status", r.fulfillmentStatus, "form", "")
	}
	if r.cancellationReason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cancellation_reason", r.cancellationReason, "form", "")
	}
	if r.orderPaymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_payment_method", r.orderPaymentMethod, "form", "")
	}
	if r.comment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comment", r.comment, "form", "")
	}
	if r.adminComment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "admin_comment", r.adminComment, "form", "")
	}
	if r.adminPrivateComment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "admin_private_comment", r.adminPrivateComment, "form", "")
	}
	if r.invoiceAdminComment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invoice_admin_comment", r.invoiceAdminComment, "form", "")
	}
	if r.dateModified != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_modified", r.dateModified, "form", "")
	}
	if r.dateFinished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_finished", r.dateFinished, "form", "")
	}
	if r.sendNotifications != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "send_notifications", r.sendNotifications, "form", "")
	} else {
		var defaultValue bool = false
		r.sendNotifications = &defaultValue
	}
	if r.createInvoice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create_invoice", r.createInvoice, "form", "")
	}
	if r.origin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origin", r.origin, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
