/*
API2Cart OpenAPI

API2Cart

API version: 1.1
Contact: contact@api2cart.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// CartAPIService CartAPI service
type CartAPIService service

type ApiCartCatalogPriceRulesCountRequest struct {
	ctx context.Context
	ApiService *CartAPIService
}

func (r ApiCartCatalogPriceRulesCountRequest) Execute() (*CartCatalogPriceRulesCount200Response, *http.Response, error) {
	return r.ApiService.CartCatalogPriceRulesCountExecute(r)
}

/*
CartCatalogPriceRulesCount cart.catalog_price_rules.count

Get count of cart catalog price rules discounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartCatalogPriceRulesCountRequest
*/
func (a *CartAPIService) CartCatalogPriceRulesCount(ctx context.Context) ApiCartCatalogPriceRulesCountRequest {
	return ApiCartCatalogPriceRulesCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartCatalogPriceRulesCount200Response
func (a *CartAPIService) CartCatalogPriceRulesCountExecute(r ApiCartCatalogPriceRulesCountRequest) (*CartCatalogPriceRulesCount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartCatalogPriceRulesCount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartCatalogPriceRulesCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.catalog_price_rules.count.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartCatalogPriceRulesListRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	start *int32
	count *int32
	pageCursor *string
	ids *string
	responseFields *string
	params *string
	exclude *string
}

// This parameter sets the number from which you want to get entities
func (r ApiCartCatalogPriceRulesListRequest) Start(start int32) ApiCartCatalogPriceRulesListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiCartCatalogPriceRulesListRequest) Count(count int32) ApiCartCatalogPriceRulesListRequest {
	r.count = &count
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiCartCatalogPriceRulesListRequest) PageCursor(pageCursor string) ApiCartCatalogPriceRulesListRequest {
	r.pageCursor = &pageCursor
	return r
}

// Retrieves  catalog_price_rules by ids
func (r ApiCartCatalogPriceRulesListRequest) Ids(ids string) ApiCartCatalogPriceRulesListRequest {
	r.ids = &ids
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartCatalogPriceRulesListRequest) ResponseFields(responseFields string) ApiCartCatalogPriceRulesListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartCatalogPriceRulesListRequest) Params(params string) ApiCartCatalogPriceRulesListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiCartCatalogPriceRulesListRequest) Exclude(exclude string) ApiCartCatalogPriceRulesListRequest {
	r.exclude = &exclude
	return r
}

func (r ApiCartCatalogPriceRulesListRequest) Execute() (*ModelResponseCartCatalogPriceRulesList, *http.Response, error) {
	return r.ApiService.CartCatalogPriceRulesListExecute(r)
}

/*
CartCatalogPriceRulesList cart.catalog_price_rules.list

Get cart catalog price rules discounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartCatalogPriceRulesListRequest
*/
func (a *CartAPIService) CartCatalogPriceRulesList(ctx context.Context) ApiCartCatalogPriceRulesListRequest {
	return ApiCartCatalogPriceRulesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseCartCatalogPriceRulesList
func (a *CartAPIService) CartCatalogPriceRulesListExecute(r ApiCartCatalogPriceRulesListRequest) (*ModelResponseCartCatalogPriceRulesList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseCartCatalogPriceRulesList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartCatalogPriceRulesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.catalog_price_rules.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,name,description"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartCouponAddRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	cartCouponAdd *CartCouponAdd
}

func (r ApiCartCouponAddRequest) CartCouponAdd(cartCouponAdd CartCouponAdd) ApiCartCouponAddRequest {
	r.cartCouponAdd = &cartCouponAdd
	return r
}

func (r ApiCartCouponAddRequest) Execute() (*CartCouponAdd200Response, *http.Response, error) {
	return r.ApiService.CartCouponAddExecute(r)
}

/*
CartCouponAdd cart.coupon.add

Use this method to create a coupon with specified conditions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartCouponAddRequest
*/
func (a *CartAPIService) CartCouponAdd(ctx context.Context) ApiCartCouponAddRequest {
	return ApiCartCouponAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartCouponAdd200Response
func (a *CartAPIService) CartCouponAddExecute(r ApiCartCouponAddRequest) (*CartCouponAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartCouponAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartCouponAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.coupon.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cartCouponAdd == nil {
		return localVarReturnValue, nil, reportError("cartCouponAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cartCouponAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartCouponConditionAddRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	couponId *string
	entity *string
	key *string
	operator *string
	value *string
	target *string
	includeTax *bool
	includeShipping *bool
	storeId *string
}

// Coupon Id
func (r ApiCartCouponConditionAddRequest) CouponId(couponId string) ApiCartCouponConditionAddRequest {
	r.couponId = &couponId
	return r
}

// Defines condition entity type
func (r ApiCartCouponConditionAddRequest) Entity(entity string) ApiCartCouponConditionAddRequest {
	r.entity = &entity
	return r
}

// Defines condition entity attribute key
func (r ApiCartCouponConditionAddRequest) Key(key string) ApiCartCouponConditionAddRequest {
	r.key = &key
	return r
}

// Defines condition operator
func (r ApiCartCouponConditionAddRequest) Operator(operator string) ApiCartCouponConditionAddRequest {
	r.operator = &operator
	return r
}

// Defines condition value, can be comma separated according to the operator.
func (r ApiCartCouponConditionAddRequest) Value(value string) ApiCartCouponConditionAddRequest {
	r.value = &value
	return r
}

// Defines condition operator
func (r ApiCartCouponConditionAddRequest) Target(target string) ApiCartCouponConditionAddRequest {
	r.target = &target
	return r
}

// Indicates whether to apply a discount for taxes.
func (r ApiCartCouponConditionAddRequest) IncludeTax(includeTax bool) ApiCartCouponConditionAddRequest {
	r.includeTax = &includeTax
	return r
}

// Indicates whether to apply a discount for shipping.
func (r ApiCartCouponConditionAddRequest) IncludeShipping(includeShipping bool) ApiCartCouponConditionAddRequest {
	r.includeShipping = &includeShipping
	return r
}

// Store Id
func (r ApiCartCouponConditionAddRequest) StoreId(storeId string) ApiCartCouponConditionAddRequest {
	r.storeId = &storeId
	return r
}

func (r ApiCartCouponConditionAddRequest) Execute() (*BasketLiveShippingServiceDelete200Response, *http.Response, error) {
	return r.ApiService.CartCouponConditionAddExecute(r)
}

/*
CartCouponConditionAdd cart.coupon.condition.add

Use this method to add additional conditions for coupon application.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartCouponConditionAddRequest
*/
func (a *CartAPIService) CartCouponConditionAdd(ctx context.Context) ApiCartCouponConditionAddRequest {
	return ApiCartCouponConditionAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BasketLiveShippingServiceDelete200Response
func (a *CartAPIService) CartCouponConditionAddExecute(r ApiCartCouponConditionAddRequest) (*BasketLiveShippingServiceDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BasketLiveShippingServiceDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartCouponConditionAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.coupon.condition.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.couponId == nil {
		return localVarReturnValue, nil, reportError("couponId is required and must be specified")
	}
	if r.entity == nil {
		return localVarReturnValue, nil, reportError("entity is required and must be specified")
	}
	if r.key == nil {
		return localVarReturnValue, nil, reportError("key is required and must be specified")
	}
	if r.operator == nil {
		return localVarReturnValue, nil, reportError("operator is required and must be specified")
	}
	if r.value == nil {
		return localVarReturnValue, nil, reportError("value is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "coupon_id", r.couponId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "entity", r.entity, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "operator", r.operator, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "form", "")
	if r.target != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target", r.target, "form", "")
	} else {
		var defaultValue string = "coupon_prerequisite"
		r.target = &defaultValue
	}
	if r.includeTax != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_tax", r.includeTax, "form", "")
	} else {
		var defaultValue bool = false
		r.includeTax = &defaultValue
	}
	if r.includeShipping != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_shipping", r.includeShipping, "form", "")
	} else {
		var defaultValue bool = false
		r.includeShipping = &defaultValue
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartCouponCountRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	storeId *string
	avail *bool
	dateStartFrom *string
	dateStartTo *string
	dateEndFrom *string
	dateEndTo *string
}

// Store Id
func (r ApiCartCouponCountRequest) StoreId(storeId string) ApiCartCouponCountRequest {
	r.storeId = &storeId
	return r
}

// Defines category&#39;s visibility status
func (r ApiCartCouponCountRequest) Avail(avail bool) ApiCartCouponCountRequest {
	r.avail = &avail
	return r
}

// Filter entity by date_start (greater or equal)
func (r ApiCartCouponCountRequest) DateStartFrom(dateStartFrom string) ApiCartCouponCountRequest {
	r.dateStartFrom = &dateStartFrom
	return r
}

// Filter entity by date_start (less or equal)
func (r ApiCartCouponCountRequest) DateStartTo(dateStartTo string) ApiCartCouponCountRequest {
	r.dateStartTo = &dateStartTo
	return r
}

// Filter entity by date_end (greater or equal)
func (r ApiCartCouponCountRequest) DateEndFrom(dateEndFrom string) ApiCartCouponCountRequest {
	r.dateEndFrom = &dateEndFrom
	return r
}

// Filter entity by date_end (less or equal)
func (r ApiCartCouponCountRequest) DateEndTo(dateEndTo string) ApiCartCouponCountRequest {
	r.dateEndTo = &dateEndTo
	return r
}

func (r ApiCartCouponCountRequest) Execute() (*CartCouponCount200Response, *http.Response, error) {
	return r.ApiService.CartCouponCountExecute(r)
}

/*
CartCouponCount cart.coupon.count

This method allows you to get the number of coupons. On some platforms, you can filter the coupons by the date they were active.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartCouponCountRequest
*/
func (a *CartAPIService) CartCouponCount(ctx context.Context) ApiCartCouponCountRequest {
	return ApiCartCouponCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartCouponCount200Response
func (a *CartAPIService) CartCouponCountExecute(r ApiCartCouponCountRequest) (*CartCouponCount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartCouponCount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartCouponCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.coupon.count.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.avail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avail", r.avail, "form", "")
	} else {
		var defaultValue bool = true
		r.avail = &defaultValue
	}
	if r.dateStartFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_start_from", r.dateStartFrom, "form", "")
	}
	if r.dateStartTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_start_to", r.dateStartTo, "form", "")
	}
	if r.dateEndFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_end_from", r.dateEndFrom, "form", "")
	}
	if r.dateEndTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_end_to", r.dateEndTo, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartCouponDeleteRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	id *string
	storeId *string
}

// Entity id
func (r ApiCartCouponDeleteRequest) Id(id string) ApiCartCouponDeleteRequest {
	r.id = &id
	return r
}

// Store Id
func (r ApiCartCouponDeleteRequest) StoreId(storeId string) ApiCartCouponDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiCartCouponDeleteRequest) Execute() (*AttributeDelete200Response, *http.Response, error) {
	return r.ApiService.CartCouponDeleteExecute(r)
}

/*
CartCouponDelete cart.coupon.delete

Delete coupon

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartCouponDeleteRequest
*/
func (a *CartAPIService) CartCouponDelete(ctx context.Context) ApiCartCouponDeleteRequest {
	return ApiCartCouponDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeDelete200Response
func (a *CartAPIService) CartCouponDeleteExecute(r ApiCartCouponDeleteRequest) (*AttributeDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartCouponDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.coupon.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartCouponListRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	start *int32
	count *int32
	pageCursor *string
	couponsIds *string
	storeId *string
	langId *string
	avail *bool
	status *string
	dateStartFrom *string
	dateStartTo *string
	dateEndFrom *string
	dateEndTo *string
	responseFields *string
	params *string
	exclude *string
}

// This parameter sets the number from which you want to get entities
func (r ApiCartCouponListRequest) Start(start int32) ApiCartCouponListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiCartCouponListRequest) Count(count int32) ApiCartCouponListRequest {
	r.count = &count
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiCartCouponListRequest) PageCursor(pageCursor string) ApiCartCouponListRequest {
	r.pageCursor = &pageCursor
	return r
}

// Filter coupons by ids
func (r ApiCartCouponListRequest) CouponsIds(couponsIds string) ApiCartCouponListRequest {
	r.couponsIds = &couponsIds
	return r
}

// Filter coupons by store id
func (r ApiCartCouponListRequest) StoreId(storeId string) ApiCartCouponListRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiCartCouponListRequest) LangId(langId string) ApiCartCouponListRequest {
	r.langId = &langId
	return r
}

// Filter coupons by avail status
func (r ApiCartCouponListRequest) Avail(avail bool) ApiCartCouponListRequest {
	r.avail = &avail
	return r
}

// Defines coupon&#39;s status
func (r ApiCartCouponListRequest) Status(status string) ApiCartCouponListRequest {
	r.status = &status
	return r
}

// Filter entity by date_start (greater or equal)
func (r ApiCartCouponListRequest) DateStartFrom(dateStartFrom string) ApiCartCouponListRequest {
	r.dateStartFrom = &dateStartFrom
	return r
}

// Filter entity by date_start (less or equal)
func (r ApiCartCouponListRequest) DateStartTo(dateStartTo string) ApiCartCouponListRequest {
	r.dateStartTo = &dateStartTo
	return r
}

// Filter entity by date_end (greater or equal)
func (r ApiCartCouponListRequest) DateEndFrom(dateEndFrom string) ApiCartCouponListRequest {
	r.dateEndFrom = &dateEndFrom
	return r
}

// Filter entity by date_end (less or equal)
func (r ApiCartCouponListRequest) DateEndTo(dateEndTo string) ApiCartCouponListRequest {
	r.dateEndTo = &dateEndTo
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartCouponListRequest) ResponseFields(responseFields string) ApiCartCouponListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartCouponListRequest) Params(params string) ApiCartCouponListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiCartCouponListRequest) Exclude(exclude string) ApiCartCouponListRequest {
	r.exclude = &exclude
	return r
}

func (r ApiCartCouponListRequest) Execute() (*ModelResponseCartCouponList, *http.Response, error) {
	return r.ApiService.CartCouponListExecute(r)
}

/*
CartCouponList cart.coupon.list

Get cart coupon discounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartCouponListRequest
*/
func (a *CartAPIService) CartCouponList(ctx context.Context) ApiCartCouponListRequest {
	return ApiCartCouponListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseCartCouponList
func (a *CartAPIService) CartCouponListExecute(r ApiCartCouponListRequest) (*ModelResponseCartCouponList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseCartCouponList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartCouponList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.coupon.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.couponsIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coupons_ids", r.couponsIds, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.avail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avail", r.avail, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.dateStartFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_start_from", r.dateStartFrom, "form", "")
	}
	if r.dateStartTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_start_to", r.dateStartTo, "form", "")
	}
	if r.dateEndFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_end_from", r.dateEndFrom, "form", "")
	}
	if r.dateEndTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date_end_to", r.dateEndTo, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,code,name,description"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartDeleteRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	deleteBridge *bool
}

// Identifies if there is a necessity to delete bridge
func (r ApiCartDeleteRequest) DeleteBridge(deleteBridge bool) ApiCartDeleteRequest {
	r.deleteBridge = &deleteBridge
	return r
}

func (r ApiCartDeleteRequest) Execute() (*CartDelete200Response, *http.Response, error) {
	return r.ApiService.CartDeleteExecute(r)
}

/*
CartDelete cart.delete

Remove store from API2Cart

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartDeleteRequest
*/
func (a *CartAPIService) CartDelete(ctx context.Context) ApiCartDeleteRequest {
	return ApiCartDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartDelete200Response
func (a *CartAPIService) CartDeleteExecute(r ApiCartDeleteRequest) (*CartDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteBridge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete_bridge", r.deleteBridge, "form", "")
	} else {
		var defaultValue bool = true
		r.deleteBridge = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartGiftcardAddRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	amount *float32
	code *string
	ownerEmail *string
	recipientEmail *string
	recipientName *string
	ownerName *string
}

// Defines the gift card amount value.
func (r ApiCartGiftcardAddRequest) Amount(amount float32) ApiCartGiftcardAddRequest {
	r.amount = &amount
	return r
}

// Gift card code
func (r ApiCartGiftcardAddRequest) Code(code string) ApiCartGiftcardAddRequest {
	r.code = &code
	return r
}

// Gift card owner email
func (r ApiCartGiftcardAddRequest) OwnerEmail(ownerEmail string) ApiCartGiftcardAddRequest {
	r.ownerEmail = &ownerEmail
	return r
}

// Gift card recipient email
func (r ApiCartGiftcardAddRequest) RecipientEmail(recipientEmail string) ApiCartGiftcardAddRequest {
	r.recipientEmail = &recipientEmail
	return r
}

// Gift card recipient name
func (r ApiCartGiftcardAddRequest) RecipientName(recipientName string) ApiCartGiftcardAddRequest {
	r.recipientName = &recipientName
	return r
}

// Gift card owner name
func (r ApiCartGiftcardAddRequest) OwnerName(ownerName string) ApiCartGiftcardAddRequest {
	r.ownerName = &ownerName
	return r
}

func (r ApiCartGiftcardAddRequest) Execute() (*CartGiftcardAdd200Response, *http.Response, error) {
	return r.ApiService.CartGiftcardAddExecute(r)
}

/*
CartGiftcardAdd cart.giftcard.add

Use this method to create a gift card for a specified amount.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartGiftcardAddRequest
*/
func (a *CartAPIService) CartGiftcardAdd(ctx context.Context) ApiCartGiftcardAddRequest {
	return ApiCartGiftcardAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartGiftcardAdd200Response
func (a *CartAPIService) CartGiftcardAddExecute(r ApiCartGiftcardAddRequest) (*CartGiftcardAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartGiftcardAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartGiftcardAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.giftcard.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "amount", r.amount, "form", "")
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "form", "")
	}
	if r.ownerEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner_email", r.ownerEmail, "form", "")
	}
	if r.recipientEmail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipient_email", r.recipientEmail, "form", "")
	}
	if r.recipientName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipient_name", r.recipientName, "form", "")
	}
	if r.ownerName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "owner_name", r.ownerName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartGiftcardCountRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	storeId *string
}

// Store Id
func (r ApiCartGiftcardCountRequest) StoreId(storeId string) ApiCartGiftcardCountRequest {
	r.storeId = &storeId
	return r
}

func (r ApiCartGiftcardCountRequest) Execute() (*CartGiftcardCount200Response, *http.Response, error) {
	return r.ApiService.CartGiftcardCountExecute(r)
}

/*
CartGiftcardCount cart.giftcard.count

Get gift cards count.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartGiftcardCountRequest
*/
func (a *CartAPIService) CartGiftcardCount(ctx context.Context) ApiCartGiftcardCountRequest {
	return ApiCartGiftcardCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartGiftcardCount200Response
func (a *CartAPIService) CartGiftcardCountExecute(r ApiCartGiftcardCountRequest) (*CartGiftcardCount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartGiftcardCount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartGiftcardCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.giftcard.count.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartGiftcardDeleteRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	id *string
}

// Entity id
func (r ApiCartGiftcardDeleteRequest) Id(id string) ApiCartGiftcardDeleteRequest {
	r.id = &id
	return r
}

func (r ApiCartGiftcardDeleteRequest) Execute() (*AttributeDelete200Response, *http.Response, error) {
	return r.ApiService.CartGiftcardDeleteExecute(r)
}

/*
CartGiftcardDelete cart.giftcard.delete

Delete giftcard

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartGiftcardDeleteRequest
*/
func (a *CartAPIService) CartGiftcardDelete(ctx context.Context) ApiCartGiftcardDeleteRequest {
	return ApiCartGiftcardDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeDelete200Response
func (a *CartAPIService) CartGiftcardDeleteExecute(r ApiCartGiftcardDeleteRequest) (*AttributeDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartGiftcardDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.giftcard.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartGiftcardListRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	start *int32
	count *int32
	pageCursor *string
	storeId *string
	responseFields *string
	params *string
	exclude *string
}

// This parameter sets the number from which you want to get entities
func (r ApiCartGiftcardListRequest) Start(start int32) ApiCartGiftcardListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiCartGiftcardListRequest) Count(count int32) ApiCartGiftcardListRequest {
	r.count = &count
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiCartGiftcardListRequest) PageCursor(pageCursor string) ApiCartGiftcardListRequest {
	r.pageCursor = &pageCursor
	return r
}

// Store Id
func (r ApiCartGiftcardListRequest) StoreId(storeId string) ApiCartGiftcardListRequest {
	r.storeId = &storeId
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartGiftcardListRequest) ResponseFields(responseFields string) ApiCartGiftcardListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartGiftcardListRequest) Params(params string) ApiCartGiftcardListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiCartGiftcardListRequest) Exclude(exclude string) ApiCartGiftcardListRequest {
	r.exclude = &exclude
	return r
}

func (r ApiCartGiftcardListRequest) Execute() (*ModelResponseCartGiftCardList, *http.Response, error) {
	return r.ApiService.CartGiftcardListExecute(r)
}

/*
CartGiftcardList cart.giftcard.list

Get gift cards list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartGiftcardListRequest
*/
func (a *CartAPIService) CartGiftcardList(ctx context.Context) ApiCartGiftcardListRequest {
	return ApiCartGiftcardListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseCartGiftCardList
func (a *CartAPIService) CartGiftcardListExecute(r ApiCartGiftcardListRequest) (*ModelResponseCartGiftCardList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseCartGiftCardList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartGiftcardList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.giftcard.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,code,name"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartInfoRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	storeId *string
	responseFields *string
	params *string
	exclude *string
}

// Store Id
func (r ApiCartInfoRequest) StoreId(storeId string) ApiCartInfoRequest {
	r.storeId = &storeId
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartInfoRequest) ResponseFields(responseFields string) ApiCartInfoRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartInfoRequest) Params(params string) ApiCartInfoRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiCartInfoRequest) Exclude(exclude string) ApiCartInfoRequest {
	r.exclude = &exclude
	return r
}

func (r ApiCartInfoRequest) Execute() (*CartInfo200Response, *http.Response, error) {
	return r.ApiService.CartInfoExecute(r)
}

/*
CartInfo cart.info

This method allows you to get various information about the store, including a list of stores (in the case of a multistore configuration), a list of supported languages, currencies, carriers, warehouses, and many other information. This information contains data that is relatively stable and rarely changes, so API2Cart can cache certain data to reduce the load on the store and speed up the execution of the request. We also recommend that you cache the response of this method on your side to save requests. If you need to clear the cache for a specific store, then use the cart.validate method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartInfoRequest
*/
func (a *CartAPIService) CartInfo(ctx context.Context) ApiCartInfoRequest {
	return ApiCartInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartInfo200Response
func (a *CartAPIService) CartInfoExecute(r ApiCartInfoRequest) (*CartInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.info.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "store_name,store_url,db_prefix"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartMetaDataListRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	entityId *string
	count *int32
	pageCursor *string
	entity *string
	storeId *string
	langId *string
	key *string
	responseFields *string
	params *string
	exclude *string
}

// Entity Id
func (r ApiCartMetaDataListRequest) EntityId(entityId string) ApiCartMetaDataListRequest {
	r.entityId = &entityId
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiCartMetaDataListRequest) Count(count int32) ApiCartMetaDataListRequest {
	r.count = &count
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiCartMetaDataListRequest) PageCursor(pageCursor string) ApiCartMetaDataListRequest {
	r.pageCursor = &pageCursor
	return r
}

// Entity
func (r ApiCartMetaDataListRequest) Entity(entity string) ApiCartMetaDataListRequest {
	r.entity = &entity
	return r
}

// Store Id
func (r ApiCartMetaDataListRequest) StoreId(storeId string) ApiCartMetaDataListRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiCartMetaDataListRequest) LangId(langId string) ApiCartMetaDataListRequest {
	r.langId = &langId
	return r
}

// Key
func (r ApiCartMetaDataListRequest) Key(key string) ApiCartMetaDataListRequest {
	r.key = &key
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartMetaDataListRequest) ResponseFields(responseFields string) ApiCartMetaDataListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartMetaDataListRequest) Params(params string) ApiCartMetaDataListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiCartMetaDataListRequest) Exclude(exclude string) ApiCartMetaDataListRequest {
	r.exclude = &exclude
	return r
}

func (r ApiCartMetaDataListRequest) Execute() (*ModelResponseCartMetaDataList, *http.Response, error) {
	return r.ApiService.CartMetaDataListExecute(r)
}

/*
CartMetaDataList cart.meta_data.list

Using this method, you can get a list of metadata for various entities (products, options, customers, orders). Usually this is data created by third-party plugins.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartMetaDataListRequest
*/
func (a *CartAPIService) CartMetaDataList(ctx context.Context) ApiCartMetaDataListRequest {
	return ApiCartMetaDataListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseCartMetaDataList
func (a *CartAPIService) CartMetaDataListExecute(r ApiCartMetaDataListRequest) (*ModelResponseCartMetaDataList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseCartMetaDataList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartMetaDataList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.meta_data.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entityId == nil {
		return localVarReturnValue, nil, reportError("entityId is required and must be specified")
	}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "entity_id", r.entityId, "form", "")
	if r.entity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entity", r.entity, "form", "")
	} else {
		var defaultValue string = "product"
		r.entity = &defaultValue
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "key,value"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartMetaDataSetRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	entityId *string
	key *string
	value *string
	namespace *string
	entity *string
	storeId *string
	langId *string
}

// Entity Id
func (r ApiCartMetaDataSetRequest) EntityId(entityId string) ApiCartMetaDataSetRequest {
	r.entityId = &entityId
	return r
}

// Key
func (r ApiCartMetaDataSetRequest) Key(key string) ApiCartMetaDataSetRequest {
	r.key = &key
	return r
}

// Value
func (r ApiCartMetaDataSetRequest) Value(value string) ApiCartMetaDataSetRequest {
	r.value = &value
	return r
}

// Metafield namespace
func (r ApiCartMetaDataSetRequest) Namespace(namespace string) ApiCartMetaDataSetRequest {
	r.namespace = &namespace
	return r
}

// Entity
func (r ApiCartMetaDataSetRequest) Entity(entity string) ApiCartMetaDataSetRequest {
	r.entity = &entity
	return r
}

// Store Id
func (r ApiCartMetaDataSetRequest) StoreId(storeId string) ApiCartMetaDataSetRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiCartMetaDataSetRequest) LangId(langId string) ApiCartMetaDataSetRequest {
	r.langId = &langId
	return r
}

func (r ApiCartMetaDataSetRequest) Execute() (*AttributeAdd200Response, *http.Response, error) {
	return r.ApiService.CartMetaDataSetExecute(r)
}

/*
CartMetaDataSet cart.meta_data.set

Set meta data for a specific entity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartMetaDataSetRequest
*/
func (a *CartAPIService) CartMetaDataSet(ctx context.Context) ApiCartMetaDataSetRequest {
	return ApiCartMetaDataSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeAdd200Response
func (a *CartAPIService) CartMetaDataSetExecute(r ApiCartMetaDataSetRequest) (*AttributeAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartMetaDataSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.meta_data.set.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entityId == nil {
		return localVarReturnValue, nil, reportError("entityId is required and must be specified")
	}
	if r.key == nil {
		return localVarReturnValue, nil, reportError("key is required and must be specified")
	}
	if r.value == nil {
		return localVarReturnValue, nil, reportError("value is required and must be specified")
	}
	if r.namespace == nil {
		return localVarReturnValue, nil, reportError("namespace is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "entity_id", r.entityId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "namespace", r.namespace, "form", "")
	if r.entity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entity", r.entity, "form", "")
	} else {
		var defaultValue string = "product"
		r.entity = &defaultValue
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartMetaDataUnsetRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	entityId *string
	key *string
	id *string
	entity *string
	storeId *string
}

// Entity Id
func (r ApiCartMetaDataUnsetRequest) EntityId(entityId string) ApiCartMetaDataUnsetRequest {
	r.entityId = &entityId
	return r
}

// Key
func (r ApiCartMetaDataUnsetRequest) Key(key string) ApiCartMetaDataUnsetRequest {
	r.key = &key
	return r
}

// Entity id
func (r ApiCartMetaDataUnsetRequest) Id(id string) ApiCartMetaDataUnsetRequest {
	r.id = &id
	return r
}

// Entity
func (r ApiCartMetaDataUnsetRequest) Entity(entity string) ApiCartMetaDataUnsetRequest {
	r.entity = &entity
	return r
}

// Store Id
func (r ApiCartMetaDataUnsetRequest) StoreId(storeId string) ApiCartMetaDataUnsetRequest {
	r.storeId = &storeId
	return r
}

func (r ApiCartMetaDataUnsetRequest) Execute() (*BasketLiveShippingServiceDelete200Response, *http.Response, error) {
	return r.ApiService.CartMetaDataUnsetExecute(r)
}

/*
CartMetaDataUnset cart.meta_data.unset

Unset meta data for a specific entity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartMetaDataUnsetRequest
*/
func (a *CartAPIService) CartMetaDataUnset(ctx context.Context) ApiCartMetaDataUnsetRequest {
	return ApiCartMetaDataUnsetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BasketLiveShippingServiceDelete200Response
func (a *CartAPIService) CartMetaDataUnsetExecute(r ApiCartMetaDataUnsetRequest) (*BasketLiveShippingServiceDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BasketLiveShippingServiceDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartMetaDataUnset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.meta_data.unset.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entityId == nil {
		return localVarReturnValue, nil, reportError("entityId is required and must be specified")
	}
	if r.key == nil {
		return localVarReturnValue, nil, reportError("key is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "entity_id", r.entityId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.entity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entity", r.entity, "form", "")
	} else {
		var defaultValue string = "product"
		r.entity = &defaultValue
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartMethodsRequest struct {
	ctx context.Context
	ApiService *CartAPIService
}

func (r ApiCartMethodsRequest) Execute() (*CartMethods200Response, *http.Response, error) {
	return r.ApiService.CartMethodsExecute(r)
}

/*
CartMethods cart.methods

Returns a list of supported API methods.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartMethodsRequest
*/
func (a *CartAPIService) CartMethods(ctx context.Context) ApiCartMethodsRequest {
	return ApiCartMethodsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartMethods200Response
func (a *CartAPIService) CartMethodsExecute(r ApiCartMethodsRequest) (*CartMethods200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartMethods200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartMethods")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.methods.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartPluginListRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	start *int32
	count *int32
	storeId *string
}

// This parameter sets the number from which you want to get entities
func (r ApiCartPluginListRequest) Start(start int32) ApiCartPluginListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiCartPluginListRequest) Count(count int32) ApiCartPluginListRequest {
	r.count = &count
	return r
}

// Store Id
func (r ApiCartPluginListRequest) StoreId(storeId string) ApiCartPluginListRequest {
	r.storeId = &storeId
	return r
}

func (r ApiCartPluginListRequest) Execute() (*CartPluginList200Response, *http.Response, error) {
	return r.ApiService.CartPluginListExecute(r)
}

/*
CartPluginList cart.plugin.list

Get a list of third-party plugins installed on the store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartPluginListRequest
*/
func (a *CartAPIService) CartPluginList(ctx context.Context) ApiCartPluginListRequest {
	return ApiCartPluginListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartPluginList200Response
func (a *CartAPIService) CartPluginListExecute(r ApiCartPluginListRequest) (*CartPluginList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartPluginList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartPluginList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.plugin.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartScriptAddRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	name *string
	description *string
	html *string
	src *string
	loadMethod *string
	scope *string
	events *string
	storeId *string
}

// The user-friendly script name
func (r ApiCartScriptAddRequest) Name(name string) ApiCartScriptAddRequest {
	r.name = &name
	return r
}

// The user-friendly description
func (r ApiCartScriptAddRequest) Description(description string) ApiCartScriptAddRequest {
	r.description = &description
	return r
}

// An html string containing exactly one &#x60;script&#x60; tag.
func (r ApiCartScriptAddRequest) Html(html string) ApiCartScriptAddRequest {
	r.html = &html
	return r
}

// The URL of the remote script
func (r ApiCartScriptAddRequest) Src(src string) ApiCartScriptAddRequest {
	r.src = &src
	return r
}

// The load method to use for the script
func (r ApiCartScriptAddRequest) LoadMethod(loadMethod string) ApiCartScriptAddRequest {
	r.loadMethod = &loadMethod
	return r
}

// The page or pages on the online store where the script should be included
func (r ApiCartScriptAddRequest) Scope(scope string) ApiCartScriptAddRequest {
	r.scope = &scope
	return r
}

// Event for run scripts
func (r ApiCartScriptAddRequest) Events(events string) ApiCartScriptAddRequest {
	r.events = &events
	return r
}

// Store Id
func (r ApiCartScriptAddRequest) StoreId(storeId string) ApiCartScriptAddRequest {
	r.storeId = &storeId
	return r
}

func (r ApiCartScriptAddRequest) Execute() (*CartScriptAdd200Response, *http.Response, error) {
	return r.ApiService.CartScriptAddExecute(r)
}

/*
CartScriptAdd cart.script.add

Add new script to the storefront

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartScriptAddRequest
*/
func (a *CartAPIService) CartScriptAdd(ctx context.Context) ApiCartScriptAddRequest {
	return ApiCartScriptAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartScriptAdd200Response
func (a *CartAPIService) CartScriptAddExecute(r ApiCartScriptAddRequest) (*CartScriptAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartScriptAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartScriptAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.script.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.html != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "html", r.html, "form", "")
	}
	if r.src != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "src", r.src, "form", "")
	}
	if r.loadMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "load_method", r.loadMethod, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "")
	} else {
		var defaultValue string = "storefront"
		r.scope = &defaultValue
	}
	if r.events != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "events", r.events, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartScriptDeleteRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	id *string
	storeId *string
}

// Entity id
func (r ApiCartScriptDeleteRequest) Id(id string) ApiCartScriptDeleteRequest {
	r.id = &id
	return r
}

// Store Id
func (r ApiCartScriptDeleteRequest) StoreId(storeId string) ApiCartScriptDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiCartScriptDeleteRequest) Execute() (*AttributeDelete200Response, *http.Response, error) {
	return r.ApiService.CartScriptDeleteExecute(r)
}

/*
CartScriptDelete cart.script.delete

Remove script from the storefront

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartScriptDeleteRequest
*/
func (a *CartAPIService) CartScriptDelete(ctx context.Context) ApiCartScriptDeleteRequest {
	return ApiCartScriptDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeDelete200Response
func (a *CartAPIService) CartScriptDeleteExecute(r ApiCartScriptDeleteRequest) (*AttributeDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartScriptDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.script.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartScriptListRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	start *int32
	count *int32
	pageCursor *string
	scriptIds *string
	storeId *string
	createdFrom *string
	createdTo *string
	modifiedFrom *string
	modifiedTo *string
	responseFields *string
	params *string
	exclude *string
}

// This parameter sets the number from which you want to get entities
func (r ApiCartScriptListRequest) Start(start int32) ApiCartScriptListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiCartScriptListRequest) Count(count int32) ApiCartScriptListRequest {
	r.count = &count
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiCartScriptListRequest) PageCursor(pageCursor string) ApiCartScriptListRequest {
	r.pageCursor = &pageCursor
	return r
}

// Retrieves only scripts with specific ids
func (r ApiCartScriptListRequest) ScriptIds(scriptIds string) ApiCartScriptListRequest {
	r.scriptIds = &scriptIds
	return r
}

// Store Id
func (r ApiCartScriptListRequest) StoreId(storeId string) ApiCartScriptListRequest {
	r.storeId = &storeId
	return r
}

// Retrieve entities from their creation date
func (r ApiCartScriptListRequest) CreatedFrom(createdFrom string) ApiCartScriptListRequest {
	r.createdFrom = &createdFrom
	return r
}

// Retrieve entities to their creation date
func (r ApiCartScriptListRequest) CreatedTo(createdTo string) ApiCartScriptListRequest {
	r.createdTo = &createdTo
	return r
}

// Retrieve entities from their modification date
func (r ApiCartScriptListRequest) ModifiedFrom(modifiedFrom string) ApiCartScriptListRequest {
	r.modifiedFrom = &modifiedFrom
	return r
}

// Retrieve entities to their modification date
func (r ApiCartScriptListRequest) ModifiedTo(modifiedTo string) ApiCartScriptListRequest {
	r.modifiedTo = &modifiedTo
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartScriptListRequest) ResponseFields(responseFields string) ApiCartScriptListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartScriptListRequest) Params(params string) ApiCartScriptListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiCartScriptListRequest) Exclude(exclude string) ApiCartScriptListRequest {
	r.exclude = &exclude
	return r
}

func (r ApiCartScriptListRequest) Execute() (*ModelResponseCartScriptList, *http.Response, error) {
	return r.ApiService.CartScriptListExecute(r)
}

/*
CartScriptList cart.script.list

Get scripts installed to the storefront

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartScriptListRequest
*/
func (a *CartAPIService) CartScriptList(ctx context.Context) ApiCartScriptListRequest {
	return ApiCartScriptListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseCartScriptList
func (a *CartAPIService) CartScriptListExecute(r ApiCartScriptListRequest) (*ModelResponseCartScriptList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseCartScriptList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartScriptList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.script.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.scriptIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "script_ids", r.scriptIds, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from", r.createdFrom, "form", "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to", r.createdTo, "form", "")
	}
	if r.modifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from", r.modifiedFrom, "form", "")
	}
	if r.modifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to", r.modifiedTo, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,name,description"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartShippingZonesListRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	start *int32
	count *int32
	storeId *string
	responseFields *string
	params *string
	exclude *string
}

// This parameter sets the number from which you want to get entities
func (r ApiCartShippingZonesListRequest) Start(start int32) ApiCartShippingZonesListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiCartShippingZonesListRequest) Count(count int32) ApiCartShippingZonesListRequest {
	r.count = &count
	return r
}

// Store Id
func (r ApiCartShippingZonesListRequest) StoreId(storeId string) ApiCartShippingZonesListRequest {
	r.storeId = &storeId
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartShippingZonesListRequest) ResponseFields(responseFields string) ApiCartShippingZonesListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiCartShippingZonesListRequest) Params(params string) ApiCartShippingZonesListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiCartShippingZonesListRequest) Exclude(exclude string) ApiCartShippingZonesListRequest {
	r.exclude = &exclude
	return r
}

func (r ApiCartShippingZonesListRequest) Execute() (*ModelResponseCartShippingZonesList, *http.Response, error) {
	return r.ApiService.CartShippingZonesListExecute(r)
}

/*
CartShippingZonesList cart.shipping_zones.list

Get list of shipping zones

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartShippingZonesListRequest
*/
func (a *CartAPIService) CartShippingZonesList(ctx context.Context) ApiCartShippingZonesListRequest {
	return ApiCartShippingZonesListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseCartShippingZonesList
func (a *CartAPIService) CartShippingZonesListExecute(r ApiCartShippingZonesListRequest) (*ModelResponseCartShippingZonesList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseCartShippingZonesList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartShippingZonesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.shipping_zones.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,name,enabled"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCartValidateRequest struct {
	ctx context.Context
	ApiService *CartAPIService
	validateVersion *bool
}

// Specify if api2cart should validate cart version
func (r ApiCartValidateRequest) ValidateVersion(validateVersion bool) ApiCartValidateRequest {
	r.validateVersion = &validateVersion
	return r
}

func (r ApiCartValidateRequest) Execute() (*CartValidate200Response, *http.Response, error) {
	return r.ApiService.CartValidateExecute(r)
}

/*
CartValidate cart.validate

This method clears the cache in API2Cart for a particular store and checks whether the connection to the store is available. Use this method if there have been any changes in the settings on the storе, for example, if a new plugin has been installed or removed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCartValidateRequest
*/
func (a *CartAPIService) CartValidate(ctx context.Context) ApiCartValidateRequest {
	return ApiCartValidateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartValidate200Response
func (a *CartAPIService) CartValidateExecute(r ApiCartValidateRequest) (*CartValidate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartValidate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CartAPIService.CartValidate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cart.validate.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.validateVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validate_version", r.validateVersion, "form", "")
	} else {
		var defaultValue bool = false
		r.validateVersion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
