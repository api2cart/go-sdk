/*
API2Cart OpenAPI

API2Cart

API version: 1.1
Contact: contact@api2cart.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// ProductAPIService ProductAPI service
type ProductAPIService service

type ApiProductAddRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productAdd *ProductAdd
}

func (r ApiProductAddRequest) ProductAdd(productAdd ProductAdd) ApiProductAddRequest {
	r.productAdd = &productAdd
	return r
}

func (r ApiProductAddRequest) Execute() (*ProductAdd200Response, *http.Response, error) {
	return r.ApiService.ProductAddExecute(r)
}

/*
ProductAdd product.add

Add new product to store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductAddRequest
*/
func (a *ProductAPIService) ProductAdd(ctx context.Context) ApiProductAddRequest {
	return ApiProductAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductAdd200Response
func (a *ProductAPIService) ProductAddExecute(r ApiProductAddRequest) (*ProductAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productAdd == nil {
		return localVarReturnValue, nil, reportError("productAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductAddBatchRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productAddBatch *ProductAddBatch
}

func (r ApiProductAddBatchRequest) ProductAddBatch(productAddBatch ProductAddBatch) ApiProductAddBatchRequest {
	r.productAddBatch = &productAddBatch
	return r
}

func (r ApiProductAddBatchRequest) Execute() (*CategoryAddBatch200Response, *http.Response, error) {
	return r.ApiService.ProductAddBatchExecute(r)
}

/*
ProductAddBatch product.add.batch

Add new products to the store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductAddBatchRequest
*/
func (a *ProductAPIService) ProductAddBatch(ctx context.Context) ApiProductAddBatchRequest {
	return ApiProductAddBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CategoryAddBatch200Response
func (a *ProductAPIService) ProductAddBatchExecute(r ApiProductAddBatchRequest) (*CategoryAddBatch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryAddBatch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductAddBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.add.batch.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productAddBatch == nil {
		return localVarReturnValue, nil, reportError("productAddBatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productAddBatch
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductAttributeListRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	attributeId *string
	variantId *string
	pageCursor *string
	start *int32
	count *int32
	attributeGroupId *string
	setName *string
	langId *string
	storeId *string
	sortBy *string
	sortDirection *string
	params *string
	responseFields *string
	exclude *string
}

// Retrieves attributes specified by product id
func (r ApiProductAttributeListRequest) ProductId(productId string) ApiProductAttributeListRequest {
	r.productId = &productId
	return r
}

// Retrieves info for specified attribute_id
func (r ApiProductAttributeListRequest) AttributeId(attributeId string) ApiProductAttributeListRequest {
	r.attributeId = &attributeId
	return r
}

// Defines product&#39;s variants specified by variant id
func (r ApiProductAttributeListRequest) VariantId(variantId string) ApiProductAttributeListRequest {
	r.variantId = &variantId
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiProductAttributeListRequest) PageCursor(pageCursor string) ApiProductAttributeListRequest {
	r.pageCursor = &pageCursor
	return r
}

// This parameter sets the number from which you want to get entities
func (r ApiProductAttributeListRequest) Start(start int32) ApiProductAttributeListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiProductAttributeListRequest) Count(count int32) ApiProductAttributeListRequest {
	r.count = &count
	return r
}

// Filter by attribute_group_id
func (r ApiProductAttributeListRequest) AttributeGroupId(attributeGroupId string) ApiProductAttributeListRequest {
	r.attributeGroupId = &attributeGroupId
	return r
}

// Retrieves attributes specified by set_name in Magento
func (r ApiProductAttributeListRequest) SetName(setName string) ApiProductAttributeListRequest {
	r.setName = &setName
	return r
}

// Retrieves attributes specified by language id
func (r ApiProductAttributeListRequest) LangId(langId string) ApiProductAttributeListRequest {
	r.langId = &langId
	return r
}

// Retrieves attributes specified by store id
func (r ApiProductAttributeListRequest) StoreId(storeId string) ApiProductAttributeListRequest {
	r.storeId = &storeId
	return r
}

// Set field to sort by
func (r ApiProductAttributeListRequest) SortBy(sortBy string) ApiProductAttributeListRequest {
	r.sortBy = &sortBy
	return r
}

// Set sorting direction
func (r ApiProductAttributeListRequest) SortDirection(sortDirection string) ApiProductAttributeListRequest {
	r.sortDirection = &sortDirection
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductAttributeListRequest) Params(params string) ApiProductAttributeListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductAttributeListRequest) ResponseFields(responseFields string) ApiProductAttributeListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiProductAttributeListRequest) Exclude(exclude string) ApiProductAttributeListRequest {
	r.exclude = &exclude
	return r
}

func (r ApiProductAttributeListRequest) Execute() (*ModelResponseProductAttributeList, *http.Response, error) {
	return r.ApiService.ProductAttributeListExecute(r)
}

/*
ProductAttributeList product.attribute.list

Get list of attributes and values.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductAttributeListRequest
*/
func (a *ProductAPIService) ProductAttributeList(ctx context.Context) ApiProductAttributeListRequest {
	return ApiProductAttributeListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseProductAttributeList
func (a *ProductAPIService) ProductAttributeListExecute(r ApiProductAttributeListRequest) (*ModelResponseProductAttributeList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseProductAttributeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductAttributeList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.attribute.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	if r.attributeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_id", r.attributeId, "form", "")
	}
	if r.variantId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variant_id", r.variantId, "form", "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.attributeGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_group_id", r.attributeGroupId, "form", "")
	}
	if r.setName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "set_name", r.setName, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	} else {
		var defaultValue string = "attribute_id"
		r.sortBy = &defaultValue
	}
	if r.sortDirection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_direction", r.sortDirection, "form", "")
	} else {
		var defaultValue string = "asc"
		r.sortDirection = &defaultValue
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "attribute_id,name"
		r.params = &defaultValue
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductAttributeValueSetRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	attributeId *string
	attributeGroupId *string
	attributeName *string
	value *string
	valueId *int32
	langId *string
	storeId *string
}

// Defines product id where the attribute should be added
func (r ApiProductAttributeValueSetRequest) ProductId(productId string) ApiProductAttributeValueSetRequest {
	r.productId = &productId
	return r
}

// Filter by attribute_id
func (r ApiProductAttributeValueSetRequest) AttributeId(attributeId string) ApiProductAttributeValueSetRequest {
	r.attributeId = &attributeId
	return r
}

// Filter by attribute_group_id
func (r ApiProductAttributeValueSetRequest) AttributeGroupId(attributeGroupId string) ApiProductAttributeValueSetRequest {
	r.attributeGroupId = &attributeGroupId
	return r
}

// Define attribute name
func (r ApiProductAttributeValueSetRequest) AttributeName(attributeName string) ApiProductAttributeValueSetRequest {
	r.attributeName = &attributeName
	return r
}

// Define attribute value
func (r ApiProductAttributeValueSetRequest) Value(value string) ApiProductAttributeValueSetRequest {
	r.value = &value
	return r
}

// Define attribute value id
func (r ApiProductAttributeValueSetRequest) ValueId(valueId int32) ApiProductAttributeValueSetRequest {
	r.valueId = &valueId
	return r
}

// Language id
func (r ApiProductAttributeValueSetRequest) LangId(langId string) ApiProductAttributeValueSetRequest {
	r.langId = &langId
	return r
}

// Store Id
func (r ApiProductAttributeValueSetRequest) StoreId(storeId string) ApiProductAttributeValueSetRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductAttributeValueSetRequest) Execute() (*ProductAttributeValueSet200Response, *http.Response, error) {
	return r.ApiService.ProductAttributeValueSetExecute(r)
}

/*
ProductAttributeValueSet product.attribute.value.set

Set attribute value to product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductAttributeValueSetRequest
*/
func (a *ProductAPIService) ProductAttributeValueSet(ctx context.Context) ApiProductAttributeValueSetRequest {
	return ApiProductAttributeValueSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductAttributeValueSet200Response
func (a *ProductAPIService) ProductAttributeValueSetExecute(r ApiProductAttributeValueSetRequest) (*ProductAttributeValueSet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductAttributeValueSet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductAttributeValueSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.attribute.value.set.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	if r.attributeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_id", r.attributeId, "form", "")
	}
	if r.attributeGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_group_id", r.attributeGroupId, "form", "")
	}
	if r.attributeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_name", r.attributeName, "form", "")
	}
	if r.value != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "form", "")
	}
	if r.valueId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "value_id", r.valueId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductAttributeValueUnsetRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	attributeId *string
	storeId *string
	includeDefault *bool
	reindex *bool
	clearCache *bool
}

// Product id
func (r ApiProductAttributeValueUnsetRequest) ProductId(productId string) ApiProductAttributeValueUnsetRequest {
	r.productId = &productId
	return r
}

// Attribute Id
func (r ApiProductAttributeValueUnsetRequest) AttributeId(attributeId string) ApiProductAttributeValueUnsetRequest {
	r.attributeId = &attributeId
	return r
}

// Store Id
func (r ApiProductAttributeValueUnsetRequest) StoreId(storeId string) ApiProductAttributeValueUnsetRequest {
	r.storeId = &storeId
	return r
}

// Boolean, whether or not to unset default value of the attribute, if applicable
func (r ApiProductAttributeValueUnsetRequest) IncludeDefault(includeDefault bool) ApiProductAttributeValueUnsetRequest {
	r.includeDefault = &includeDefault
	return r
}

// Is reindex required
func (r ApiProductAttributeValueUnsetRequest) Reindex(reindex bool) ApiProductAttributeValueUnsetRequest {
	r.reindex = &reindex
	return r
}

// Is cache clear required
func (r ApiProductAttributeValueUnsetRequest) ClearCache(clearCache bool) ApiProductAttributeValueUnsetRequest {
	r.clearCache = &clearCache
	return r
}

func (r ApiProductAttributeValueUnsetRequest) Execute() (*ProductAttributeValueUnset200Response, *http.Response, error) {
	return r.ApiService.ProductAttributeValueUnsetExecute(r)
}

/*
ProductAttributeValueUnset product.attribute.value.unset

Removes attribute value for a product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductAttributeValueUnsetRequest
*/
func (a *ProductAPIService) ProductAttributeValueUnset(ctx context.Context) ApiProductAttributeValueUnsetRequest {
	return ApiProductAttributeValueUnsetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductAttributeValueUnset200Response
func (a *ProductAPIService) ProductAttributeValueUnsetExecute(r ApiProductAttributeValueUnsetRequest) (*ProductAttributeValueUnset200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductAttributeValueUnset200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductAttributeValueUnset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.attribute.value.unset.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.attributeId == nil {
		return localVarReturnValue, nil, reportError("attributeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_id", r.attributeId, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.includeDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_default", r.includeDefault, "form", "")
	} else {
		var defaultValue bool = false
		r.includeDefault = &defaultValue
	}
	if r.reindex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reindex", r.reindex, "form", "")
	} else {
		var defaultValue bool = true
		r.reindex = &defaultValue
	}
	if r.clearCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clear_cache", r.clearCache, "form", "")
	} else {
		var defaultValue bool = true
		r.clearCache = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductBrandListRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	start *int32
	count *int32
	pageCursor *string
	params *string
	brandIds *string
	exclude *string
	categoryId *string
	storeId *string
	langId *string
	createdFrom *string
	createdTo *string
	modifiedFrom *string
	modifiedTo *string
	parentId *string
	responseFields *string
	findWhere *string
	findValue *string
}

// This parameter sets the number from which you want to get entities
func (r ApiProductBrandListRequest) Start(start int32) ApiProductBrandListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiProductBrandListRequest) Count(count int32) ApiProductBrandListRequest {
	r.count = &count
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiProductBrandListRequest) PageCursor(pageCursor string) ApiProductBrandListRequest {
	r.pageCursor = &pageCursor
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductBrandListRequest) Params(params string) ApiProductBrandListRequest {
	r.params = &params
	return r
}

// Retrieves brands specified by brand ids
func (r ApiProductBrandListRequest) BrandIds(brandIds string) ApiProductBrandListRequest {
	r.brandIds = &brandIds
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiProductBrandListRequest) Exclude(exclude string) ApiProductBrandListRequest {
	r.exclude = &exclude
	return r
}

// Retrieves product brands specified by category id
func (r ApiProductBrandListRequest) CategoryId(categoryId string) ApiProductBrandListRequest {
	r.categoryId = &categoryId
	return r
}

// Store Id
func (r ApiProductBrandListRequest) StoreId(storeId string) ApiProductBrandListRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiProductBrandListRequest) LangId(langId string) ApiProductBrandListRequest {
	r.langId = &langId
	return r
}

// Retrieve entities from their creation date
func (r ApiProductBrandListRequest) CreatedFrom(createdFrom string) ApiProductBrandListRequest {
	r.createdFrom = &createdFrom
	return r
}

// Retrieve entities to their creation date
func (r ApiProductBrandListRequest) CreatedTo(createdTo string) ApiProductBrandListRequest {
	r.createdTo = &createdTo
	return r
}

// Retrieve entities from their modification date
func (r ApiProductBrandListRequest) ModifiedFrom(modifiedFrom string) ApiProductBrandListRequest {
	r.modifiedFrom = &modifiedFrom
	return r
}

// Retrieve entities to their modification date
func (r ApiProductBrandListRequest) ModifiedTo(modifiedTo string) ApiProductBrandListRequest {
	r.modifiedTo = &modifiedTo
	return r
}

// Retrieves brands specified by parent id
func (r ApiProductBrandListRequest) ParentId(parentId string) ApiProductBrandListRequest {
	r.parentId = &parentId
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductBrandListRequest) ResponseFields(responseFields string) ApiProductBrandListRequest {
	r.responseFields = &responseFields
	return r
}

// Entity search that is specified by the comma-separated unique fields
func (r ApiProductBrandListRequest) FindWhere(findWhere string) ApiProductBrandListRequest {
	r.findWhere = &findWhere
	return r
}

// Entity search that is specified by some value
func (r ApiProductBrandListRequest) FindValue(findValue string) ApiProductBrandListRequest {
	r.findValue = &findValue
	return r
}

func (r ApiProductBrandListRequest) Execute() (*ModelResponseProductBrandList, *http.Response, error) {
	return r.ApiService.ProductBrandListExecute(r)
}

/*
ProductBrandList product.brand.list

Get list of brands from your store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductBrandListRequest
*/
func (a *ProductAPIService) ProductBrandList(ctx context.Context) ApiProductBrandListRequest {
	return ApiProductBrandListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseProductBrandList
func (a *ProductAPIService) ProductBrandListExecute(r ApiProductBrandListRequest) (*ModelResponseProductBrandList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseProductBrandList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductBrandList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.brand.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,name,short_description,active,url"
		r.params = &defaultValue
	}
	if r.brandIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "brand_ids", r.brandIds, "form", "")
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.categoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category_id", r.categoryId, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from", r.createdFrom, "form", "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to", r.createdTo, "form", "")
	}
	if r.modifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from", r.modifiedFrom, "form", "")
	}
	if r.modifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to", r.modifiedTo, "form", "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_id", r.parentId, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.findWhere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_where", r.findWhere, "form", "")
	}
	if r.findValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_value", r.findValue, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductChildItemFindRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	findValue *string
	findWhere *string
	findParams *string
	storeId *string
}

// Entity search that is specified by some value
func (r ApiProductChildItemFindRequest) FindValue(findValue string) ApiProductChildItemFindRequest {
	r.findValue = &findValue
	return r
}

// Entity search that is specified by the comma-separated unique fields
func (r ApiProductChildItemFindRequest) FindWhere(findWhere string) ApiProductChildItemFindRequest {
	r.findWhere = &findWhere
	return r
}

// Entity search that is specified by comma-separated parameters
func (r ApiProductChildItemFindRequest) FindParams(findParams string) ApiProductChildItemFindRequest {
	r.findParams = &findParams
	return r
}

// Store Id
func (r ApiProductChildItemFindRequest) StoreId(storeId string) ApiProductChildItemFindRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductChildItemFindRequest) Execute() (*ProductChildItemFind200Response, *http.Response, error) {
	return r.ApiService.ProductChildItemFindExecute(r)
}

/*
ProductChildItemFind product.child_item.find

Search product child item (bundled item or configurable product variant) in store catalog.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductChildItemFindRequest
*/
func (a *ProductAPIService) ProductChildItemFind(ctx context.Context) ApiProductChildItemFindRequest {
	return ApiProductChildItemFindRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductChildItemFind200Response
func (a *ProductAPIService) ProductChildItemFindExecute(r ApiProductChildItemFindRequest) (*ProductChildItemFind200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductChildItemFind200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductChildItemFind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.child_item.find.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.findValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_value", r.findValue, "form", "")
	}
	if r.findWhere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_where", r.findWhere, "form", "")
	}
	if r.findParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_params", r.findParams, "form", "")
	} else {
		var defaultValue string = "whole_words"
		r.findParams = &defaultValue
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductChildItemInfoRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	id *string
	params *string
	responseFields *string
	exclude *string
	storeId *string
	langId *string
	currencyId *string
	useLatestApiVersion *bool
}

// Filter by parent product id
func (r ApiProductChildItemInfoRequest) ProductId(productId string) ApiProductChildItemInfoRequest {
	r.productId = &productId
	return r
}

// Entity id
func (r ApiProductChildItemInfoRequest) Id(id string) ApiProductChildItemInfoRequest {
	r.id = &id
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductChildItemInfoRequest) Params(params string) ApiProductChildItemInfoRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductChildItemInfoRequest) ResponseFields(responseFields string) ApiProductChildItemInfoRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiProductChildItemInfoRequest) Exclude(exclude string) ApiProductChildItemInfoRequest {
	r.exclude = &exclude
	return r
}

// Store Id
func (r ApiProductChildItemInfoRequest) StoreId(storeId string) ApiProductChildItemInfoRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiProductChildItemInfoRequest) LangId(langId string) ApiProductChildItemInfoRequest {
	r.langId = &langId
	return r
}

// Currency Id
func (r ApiProductChildItemInfoRequest) CurrencyId(currencyId string) ApiProductChildItemInfoRequest {
	r.currencyId = &currencyId
	return r
}

// Use the latest platform API version
func (r ApiProductChildItemInfoRequest) UseLatestApiVersion(useLatestApiVersion bool) ApiProductChildItemInfoRequest {
	r.useLatestApiVersion = &useLatestApiVersion
	return r
}

func (r ApiProductChildItemInfoRequest) Execute() (*ProductChildItemInfo200Response, *http.Response, error) {
	return r.ApiService.ProductChildItemInfoExecute(r)
}

/*
ProductChildItemInfo product.child_item.info

Get child for specific product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductChildItemInfoRequest
*/
func (a *ProductAPIService) ProductChildItemInfo(ctx context.Context) ApiProductChildItemInfoRequest {
	return ApiProductChildItemInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductChildItemInfo200Response
func (a *ProductAPIService) ProductChildItemInfoExecute(r ApiProductChildItemInfoRequest) (*ProductChildItemInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductChildItemInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductChildItemInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.child_item.info.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "force_all"
		r.params = &defaultValue
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency_id", r.currencyId, "form", "")
	}
	if r.useLatestApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_latest_api_version", r.useLatestApiVersion, "form", "")
	} else {
		var defaultValue bool = false
		r.useLatestApiVersion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductChildItemListRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	pageCursor *string
	start *int32
	count *int32
	params *string
	responseFields *string
	exclude *string
	createdFrom *string
	createdTo *string
	modifiedFrom *string
	modifiedTo *string
	productId *string
	productIds *string
	sku *string
	storeId *string
	langId *string
	currencyId *string
	availSale *bool
	findValue *string
	findWhere *string
	reportRequestId *string
	disableReportCache *bool
	useLatestApiVersion *bool
	returnGlobal *bool
}

// Used to retrieve products child items via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiProductChildItemListRequest) PageCursor(pageCursor string) ApiProductChildItemListRequest {
	r.pageCursor = &pageCursor
	return r
}

// This parameter sets the number from which you want to get entities
func (r ApiProductChildItemListRequest) Start(start int32) ApiProductChildItemListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiProductChildItemListRequest) Count(count int32) ApiProductChildItemListRequest {
	r.count = &count
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductChildItemListRequest) Params(params string) ApiProductChildItemListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductChildItemListRequest) ResponseFields(responseFields string) ApiProductChildItemListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiProductChildItemListRequest) Exclude(exclude string) ApiProductChildItemListRequest {
	r.exclude = &exclude
	return r
}

// Retrieve entities from their creation date
func (r ApiProductChildItemListRequest) CreatedFrom(createdFrom string) ApiProductChildItemListRequest {
	r.createdFrom = &createdFrom
	return r
}

// Retrieve entities to their creation date
func (r ApiProductChildItemListRequest) CreatedTo(createdTo string) ApiProductChildItemListRequest {
	r.createdTo = &createdTo
	return r
}

// Retrieve entities from their modification date
func (r ApiProductChildItemListRequest) ModifiedFrom(modifiedFrom string) ApiProductChildItemListRequest {
	r.modifiedFrom = &modifiedFrom
	return r
}

// Retrieve entities to their modification date
func (r ApiProductChildItemListRequest) ModifiedTo(modifiedTo string) ApiProductChildItemListRequest {
	r.modifiedTo = &modifiedTo
	return r
}

// Filter by parent product id
func (r ApiProductChildItemListRequest) ProductId(productId string) ApiProductChildItemListRequest {
	r.productId = &productId
	return r
}

// Filter by parent product ids
func (r ApiProductChildItemListRequest) ProductIds(productIds string) ApiProductChildItemListRequest {
	r.productIds = &productIds
	return r
}

// Filter by products variant&#39;s sku
func (r ApiProductChildItemListRequest) Sku(sku string) ApiProductChildItemListRequest {
	r.sku = &sku
	return r
}

// Store Id
func (r ApiProductChildItemListRequest) StoreId(storeId string) ApiProductChildItemListRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiProductChildItemListRequest) LangId(langId string) ApiProductChildItemListRequest {
	r.langId = &langId
	return r
}

// Currency Id
func (r ApiProductChildItemListRequest) CurrencyId(currencyId string) ApiProductChildItemListRequest {
	r.currencyId = &currencyId
	return r
}

// Specifies the set of available/not available products for sale
func (r ApiProductChildItemListRequest) AvailSale(availSale bool) ApiProductChildItemListRequest {
	r.availSale = &availSale
	return r
}

// Entity search that is specified by some value
func (r ApiProductChildItemListRequest) FindValue(findValue string) ApiProductChildItemListRequest {
	r.findValue = &findValue
	return r
}

// Child products search that is specified by field
func (r ApiProductChildItemListRequest) FindWhere(findWhere string) ApiProductChildItemListRequest {
	r.findWhere = &findWhere
	return r
}

// Report request id
func (r ApiProductChildItemListRequest) ReportRequestId(reportRequestId string) ApiProductChildItemListRequest {
	r.reportRequestId = &reportRequestId
	return r
}

// Disable report cache for current request
func (r ApiProductChildItemListRequest) DisableReportCache(disableReportCache bool) ApiProductChildItemListRequest {
	r.disableReportCache = &disableReportCache
	return r
}

// Use the latest platform API version
func (r ApiProductChildItemListRequest) UseLatestApiVersion(useLatestApiVersion bool) ApiProductChildItemListRequest {
	r.useLatestApiVersion = &useLatestApiVersion
	return r
}

// Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned.
func (r ApiProductChildItemListRequest) ReturnGlobal(returnGlobal bool) ApiProductChildItemListRequest {
	r.returnGlobal = &returnGlobal
	return r
}

func (r ApiProductChildItemListRequest) Execute() (*ModelResponseProductChildItemList, *http.Response, error) {
	return r.ApiService.ProductChildItemListExecute(r)
}

/*
ProductChildItemList product.child_item.list

Get a list of a product's child items, such as variants or bundle components. The total_count field in the response indicates the total number of items in the context of the current filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductChildItemListRequest
*/
func (a *ProductAPIService) ProductChildItemList(ctx context.Context) ApiProductChildItemListRequest {
	return ApiProductChildItemListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseProductChildItemList
func (a *ProductAPIService) ProductChildItemListExecute(r ApiProductChildItemListRequest) (*ModelResponseProductChildItemList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseProductChildItemList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductChildItemList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.child_item.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "force_all"
		r.params = &defaultValue
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from", r.createdFrom, "form", "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to", r.createdTo, "form", "")
	}
	if r.modifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from", r.modifiedFrom, "form", "")
	}
	if r.modifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to", r.modifiedTo, "form", "")
	}
	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	}
	if r.productIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_ids", r.productIds, "form", "")
	}
	if r.sku != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sku", r.sku, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency_id", r.currencyId, "form", "")
	}
	if r.availSale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avail_sale", r.availSale, "form", "")
	}
	if r.findValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_value", r.findValue, "form", "")
	}
	if r.findWhere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_where", r.findWhere, "form", "")
	}
	if r.reportRequestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "report_request_id", r.reportRequestId, "form", "")
	}
	if r.disableReportCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_report_cache", r.disableReportCache, "form", "")
	} else {
		var defaultValue bool = false
		r.disableReportCache = &defaultValue
	}
	if r.useLatestApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_latest_api_version", r.useLatestApiVersion, "form", "")
	} else {
		var defaultValue bool = false
		r.useLatestApiVersion = &defaultValue
	}
	if r.returnGlobal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "return_global", r.returnGlobal, "form", "")
	} else {
		var defaultValue bool = false
		r.returnGlobal = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductCountRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	categoryId *string
	createdFrom *string
	createdTo *string
	modifiedFrom *string
	modifiedTo *string
	availView *bool
	availSale *bool
	storeId *string
	langId *string
	productIds *string
	sinceId *string
	reportRequestId *string
	disableReportCache *bool
	brandName *string
	productAttributes *[]string
	status *string
	type_ *string
	findValue *string
	findWhere *string
	useLatestApiVersion *bool
	returnGlobal *bool
	categoriesIds *string
}

// Counts products specified by category id
func (r ApiProductCountRequest) CategoryId(categoryId string) ApiProductCountRequest {
	r.categoryId = &categoryId
	return r
}

// Retrieve entities from their creation date
func (r ApiProductCountRequest) CreatedFrom(createdFrom string) ApiProductCountRequest {
	r.createdFrom = &createdFrom
	return r
}

// Retrieve entities to their creation date
func (r ApiProductCountRequest) CreatedTo(createdTo string) ApiProductCountRequest {
	r.createdTo = &createdTo
	return r
}

// Retrieve entities from their modification date
func (r ApiProductCountRequest) ModifiedFrom(modifiedFrom string) ApiProductCountRequest {
	r.modifiedFrom = &modifiedFrom
	return r
}

// Retrieve entities to their modification date
func (r ApiProductCountRequest) ModifiedTo(modifiedTo string) ApiProductCountRequest {
	r.modifiedTo = &modifiedTo
	return r
}

// Specifies the set of visible/invisible products
func (r ApiProductCountRequest) AvailView(availView bool) ApiProductCountRequest {
	r.availView = &availView
	return r
}

// Specifies the set of available/not available products for sale
func (r ApiProductCountRequest) AvailSale(availSale bool) ApiProductCountRequest {
	r.availSale = &availSale
	return r
}

// Counts products specified by store id
func (r ApiProductCountRequest) StoreId(storeId string) ApiProductCountRequest {
	r.storeId = &storeId
	return r
}

// Counts products specified by language id
func (r ApiProductCountRequest) LangId(langId string) ApiProductCountRequest {
	r.langId = &langId
	return r
}

// Counts products specified by product ids
func (r ApiProductCountRequest) ProductIds(productIds string) ApiProductCountRequest {
	r.productIds = &productIds
	return r
}

// Retrieve entities starting from the specified id.
func (r ApiProductCountRequest) SinceId(sinceId string) ApiProductCountRequest {
	r.sinceId = &sinceId
	return r
}

// Report request id
func (r ApiProductCountRequest) ReportRequestId(reportRequestId string) ApiProductCountRequest {
	r.reportRequestId = &reportRequestId
	return r
}

// Disable report cache for current request
func (r ApiProductCountRequest) DisableReportCache(disableReportCache bool) ApiProductCountRequest {
	r.disableReportCache = &disableReportCache
	return r
}

// Retrieves brands specified by brand name
func (r ApiProductCountRequest) BrandName(brandName string) ApiProductCountRequest {
	r.brandName = &brandName
	return r
}

// Defines product attributes
func (r ApiProductCountRequest) ProductAttributes(productAttributes []string) ApiProductCountRequest {
	r.productAttributes = &productAttributes
	return r
}

// Defines product&#39;s status
func (r ApiProductCountRequest) Status(status string) ApiProductCountRequest {
	r.status = &status
	return r
}

// Defines products&#39;s type
func (r ApiProductCountRequest) Type_(type_ string) ApiProductCountRequest {
	r.type_ = &type_
	return r
}

// Entity search that is specified by some value
func (r ApiProductCountRequest) FindValue(findValue string) ApiProductCountRequest {
	r.findValue = &findValue
	return r
}

// Counts products that are searched specified by field
func (r ApiProductCountRequest) FindWhere(findWhere string) ApiProductCountRequest {
	r.findWhere = &findWhere
	return r
}

// Use the latest platform API version
func (r ApiProductCountRequest) UseLatestApiVersion(useLatestApiVersion bool) ApiProductCountRequest {
	r.useLatestApiVersion = &useLatestApiVersion
	return r
}

// Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned.
func (r ApiProductCountRequest) ReturnGlobal(returnGlobal bool) ApiProductCountRequest {
	r.returnGlobal = &returnGlobal
	return r
}

// Defines product add that is specified by comma-separated categories id
func (r ApiProductCountRequest) CategoriesIds(categoriesIds string) ApiProductCountRequest {
	r.categoriesIds = &categoriesIds
	return r
}

func (r ApiProductCountRequest) Execute() (*ProductCount200Response, *http.Response, error) {
	return r.ApiService.ProductCountExecute(r)
}

/*
ProductCount product.count

Count products in store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductCountRequest
*/
func (a *ProductAPIService) ProductCount(ctx context.Context) ApiProductCountRequest {
	return ApiProductCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductCount200Response
func (a *ProductAPIService) ProductCountExecute(r ApiProductCountRequest) (*ProductCount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductCount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.count.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.categoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category_id", r.categoryId, "form", "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from", r.createdFrom, "form", "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to", r.createdTo, "form", "")
	}
	if r.modifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from", r.modifiedFrom, "form", "")
	}
	if r.modifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to", r.modifiedTo, "form", "")
	}
	if r.availView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avail_view", r.availView, "form", "")
	}
	if r.availSale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avail_sale", r.availSale, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.productIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_ids", r.productIds, "form", "")
	}
	if r.sinceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_id", r.sinceId, "form", "")
	}
	if r.reportRequestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "report_request_id", r.reportRequestId, "form", "")
	}
	if r.disableReportCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_report_cache", r.disableReportCache, "form", "")
	} else {
		var defaultValue bool = false
		r.disableReportCache = &defaultValue
	}
	if r.brandName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "brand_name", r.brandName, "form", "")
	}
	if r.productAttributes != nil {
		t := *r.productAttributes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "product_attributes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "product_attributes", t, "form", "multi")
		}
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.findValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_value", r.findValue, "form", "")
	}
	if r.findWhere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_where", r.findWhere, "form", "")
	}
	if r.useLatestApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_latest_api_version", r.useLatestApiVersion, "form", "")
	} else {
		var defaultValue bool = false
		r.useLatestApiVersion = &defaultValue
	}
	if r.returnGlobal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "return_global", r.returnGlobal, "form", "")
	} else {
		var defaultValue bool = false
		r.returnGlobal = &defaultValue
	}
	if r.categoriesIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categories_ids", r.categoriesIds, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductCurrencyAddRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	iso3 *string
	rate *float32
	name *string
	avail *bool
	symbolLeft *string
	symbolRight *string
	default_ *bool
}

// Specifies standardized currency code
func (r ApiProductCurrencyAddRequest) Iso3(iso3 string) ApiProductCurrencyAddRequest {
	r.iso3 = &iso3
	return r
}

// Defines the numerical identifier against to the major currency
func (r ApiProductCurrencyAddRequest) Rate(rate float32) ApiProductCurrencyAddRequest {
	r.rate = &rate
	return r
}

// Defines currency&#39;s name
func (r ApiProductCurrencyAddRequest) Name(name string) ApiProductCurrencyAddRequest {
	r.name = &name
	return r
}

// Specifies whether the currency is available
func (r ApiProductCurrencyAddRequest) Avail(avail bool) ApiProductCurrencyAddRequest {
	r.avail = &avail
	return r
}

// Defines the symbol that is located before the currency
func (r ApiProductCurrencyAddRequest) SymbolLeft(symbolLeft string) ApiProductCurrencyAddRequest {
	r.symbolLeft = &symbolLeft
	return r
}

// Defines the symbol that is located after the currency
func (r ApiProductCurrencyAddRequest) SymbolRight(symbolRight string) ApiProductCurrencyAddRequest {
	r.symbolRight = &symbolRight
	return r
}

// Specifies currency&#39;s default meaning
func (r ApiProductCurrencyAddRequest) Default_(default_ bool) ApiProductCurrencyAddRequest {
	r.default_ = &default_
	return r
}

func (r ApiProductCurrencyAddRequest) Execute() (*ProductCurrencyAdd200Response, *http.Response, error) {
	return r.ApiService.ProductCurrencyAddExecute(r)
}

/*
ProductCurrencyAdd product.currency.add

Add currency and/or set default in store

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductCurrencyAddRequest
*/
func (a *ProductAPIService) ProductCurrencyAdd(ctx context.Context) ApiProductCurrencyAddRequest {
	return ApiProductCurrencyAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductCurrencyAdd200Response
func (a *ProductAPIService) ProductCurrencyAddExecute(r ApiProductCurrencyAddRequest) (*ProductCurrencyAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductCurrencyAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductCurrencyAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.currency.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.iso3 == nil {
		return localVarReturnValue, nil, reportError("iso3 is required and must be specified")
	}
	if r.rate == nil {
		return localVarReturnValue, nil, reportError("rate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "iso3", r.iso3, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "rate", r.rate, "form", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.avail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avail", r.avail, "form", "")
	} else {
		var defaultValue bool = true
		r.avail = &defaultValue
	}
	if r.symbolLeft != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol_left", r.symbolLeft, "form", "")
	}
	if r.symbolRight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol_right", r.symbolRight, "form", "")
	}
	if r.default_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default", r.default_, "form", "")
	} else {
		var defaultValue bool = false
		r.default_ = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductCurrencyListRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	start *int32
	count *int32
	params *string
	pageCursor *string
	exclude *string
	responseFields *string
	default_ *bool
	avail *bool
}

// This parameter sets the number from which you want to get entities
func (r ApiProductCurrencyListRequest) Start(start int32) ApiProductCurrencyListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiProductCurrencyListRequest) Count(count int32) ApiProductCurrencyListRequest {
	r.count = &count
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductCurrencyListRequest) Params(params string) ApiProductCurrencyListRequest {
	r.params = &params
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiProductCurrencyListRequest) PageCursor(pageCursor string) ApiProductCurrencyListRequest {
	r.pageCursor = &pageCursor
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiProductCurrencyListRequest) Exclude(exclude string) ApiProductCurrencyListRequest {
	r.exclude = &exclude
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductCurrencyListRequest) ResponseFields(responseFields string) ApiProductCurrencyListRequest {
	r.responseFields = &responseFields
	return r
}

// Specifies the set of default/not default currencies
func (r ApiProductCurrencyListRequest) Default_(default_ bool) ApiProductCurrencyListRequest {
	r.default_ = &default_
	return r
}

// Specifies the set of available/not available currencies
func (r ApiProductCurrencyListRequest) Avail(avail bool) ApiProductCurrencyListRequest {
	r.avail = &avail
	return r
}

func (r ApiProductCurrencyListRequest) Execute() (*ModelResponseProductCurrencyList, *http.Response, error) {
	return r.ApiService.ProductCurrencyListExecute(r)
}

/*
ProductCurrencyList product.currency.list

Get list of currencies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductCurrencyListRequest
*/
func (a *ProductAPIService) ProductCurrencyList(ctx context.Context) ApiProductCurrencyListRequest {
	return ApiProductCurrencyListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseProductCurrencyList
func (a *ProductAPIService) ProductCurrencyListExecute(r ApiProductCurrencyListRequest) (*ModelResponseProductCurrencyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseProductCurrencyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductCurrencyList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.currency.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "name,iso3,default,avail"
		r.params = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.default_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default", r.default_, "form", "")
	}
	if r.avail != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avail", r.avail, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductDeleteRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	id *string
	storeId *string
}

// Product id that will be removed
func (r ApiProductDeleteRequest) Id(id string) ApiProductDeleteRequest {
	r.id = &id
	return r
}

// Store Id
func (r ApiProductDeleteRequest) StoreId(storeId string) ApiProductDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductDeleteRequest) Execute() (*CustomerDelete200Response, *http.Response, error) {
	return r.ApiService.ProductDeleteExecute(r)
}

/*
ProductDelete product.delete

Product delete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductDeleteRequest
*/
func (a *ProductAPIService) ProductDelete(ctx context.Context) ApiProductDeleteRequest {
	return ApiProductDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CustomerDelete200Response
func (a *ProductAPIService) ProductDeleteExecute(r ApiProductDeleteRequest) (*CustomerDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductDeleteBatchRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productDeleteBatch *ProductDeleteBatch
}

func (r ApiProductDeleteBatchRequest) ProductDeleteBatch(productDeleteBatch ProductDeleteBatch) ApiProductDeleteBatchRequest {
	r.productDeleteBatch = &productDeleteBatch
	return r
}

func (r ApiProductDeleteBatchRequest) Execute() (*CategoryAddBatch200Response, *http.Response, error) {
	return r.ApiService.ProductDeleteBatchExecute(r)
}

/*
ProductDeleteBatch product.delete.batch

Remove product from the store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductDeleteBatchRequest
*/
func (a *ProductAPIService) ProductDeleteBatch(ctx context.Context) ApiProductDeleteBatchRequest {
	return ApiProductDeleteBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CategoryAddBatch200Response
func (a *ProductAPIService) ProductDeleteBatchExecute(r ApiProductDeleteBatchRequest) (*CategoryAddBatch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryAddBatch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductDeleteBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.delete.batch.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productDeleteBatch == nil {
		return localVarReturnValue, nil, reportError("productDeleteBatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productDeleteBatch
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductFieldsRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
}

func (r ApiProductFieldsRequest) Execute() (*CartConfigUpdate200Response, *http.Response, error) {
	return r.ApiService.ProductFieldsExecute(r)
}

/*
ProductFields product.fields

Retrieve all available fields for product item in store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductFieldsRequest

Deprecated
*/
func (a *ProductAPIService) ProductFields(ctx context.Context) ApiProductFieldsRequest {
	return ApiProductFieldsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartConfigUpdate200Response
// Deprecated
func (a *ProductAPIService) ProductFieldsExecute(r ApiProductFieldsRequest) (*CartConfigUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartConfigUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductFields")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.fields.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductFindRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	findValue *string
	findWhere *string
	findParams *string
	findWhat *string
	langId *string
	storeId *string
}

// Entity search that is specified by some value
func (r ApiProductFindRequest) FindValue(findValue string) ApiProductFindRequest {
	r.findValue = &findValue
	return r
}

// Entity search that is specified by the comma-separated unique fields
func (r ApiProductFindRequest) FindWhere(findWhere string) ApiProductFindRequest {
	r.findWhere = &findWhere
	return r
}

// Entity search that is specified by comma-separated parameters
func (r ApiProductFindRequest) FindParams(findParams string) ApiProductFindRequest {
	r.findParams = &findParams
	return r
}

// Parameter&#39;s value specifies the entity that has to be found
func (r ApiProductFindRequest) FindWhat(findWhat string) ApiProductFindRequest {
	r.findWhat = &findWhat
	return r
}

// Search products specified by language id
func (r ApiProductFindRequest) LangId(langId string) ApiProductFindRequest {
	r.langId = &langId
	return r
}

// Store Id
func (r ApiProductFindRequest) StoreId(storeId string) ApiProductFindRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductFindRequest) Execute() (*ProductFind200Response, *http.Response, error) {
	return r.ApiService.ProductFindExecute(r)
}

/*
ProductFind product.find

Search product in store catalog. "Apple" is specified here by default.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductFindRequest
*/
func (a *ProductAPIService) ProductFind(ctx context.Context) ApiProductFindRequest {
	return ApiProductFindRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductFind200Response
func (a *ProductAPIService) ProductFindExecute(r ApiProductFindRequest) (*ProductFind200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductFind200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductFind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.find.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.findValue == nil {
		return localVarReturnValue, nil, reportError("findValue is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "find_value", r.findValue, "form", "")
	if r.findWhere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_where", r.findWhere, "form", "")
	} else {
		var defaultValue string = "name"
		r.findWhere = &defaultValue
	}
	if r.findParams != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_params", r.findParams, "form", "")
	} else {
		var defaultValue string = "whole_words"
		r.findParams = &defaultValue
	}
	if r.findWhat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_what", r.findWhat, "form", "")
	} else {
		var defaultValue string = "product"
		r.findWhat = &defaultValue
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductImageAddRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productImageAdd *ProductImageAdd
}

func (r ApiProductImageAddRequest) ProductImageAdd(productImageAdd ProductImageAdd) ApiProductImageAddRequest {
	r.productImageAdd = &productImageAdd
	return r
}

func (r ApiProductImageAddRequest) Execute() (*ProductImageAdd200Response, *http.Response, error) {
	return r.ApiService.ProductImageAddExecute(r)
}

/*
ProductImageAdd product.image.add

Add image to product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductImageAddRequest
*/
func (a *ProductAPIService) ProductImageAdd(ctx context.Context) ApiProductImageAddRequest {
	return ApiProductImageAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductImageAdd200Response
func (a *ProductAPIService) ProductImageAddExecute(r ApiProductImageAddRequest) (*ProductImageAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductImageAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductImageAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.image.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productImageAdd == nil {
		return localVarReturnValue, nil, reportError("productImageAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productImageAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductImageDeleteRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	id *string
	storeId *string
}

// Defines product id where the image should be deleted
func (r ApiProductImageDeleteRequest) ProductId(productId string) ApiProductImageDeleteRequest {
	r.productId = &productId
	return r
}

// Entity id
func (r ApiProductImageDeleteRequest) Id(id string) ApiProductImageDeleteRequest {
	r.id = &id
	return r
}

// Store Id
func (r ApiProductImageDeleteRequest) StoreId(storeId string) ApiProductImageDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductImageDeleteRequest) Execute() (*AttributeDelete200Response, *http.Response, error) {
	return r.ApiService.ProductImageDeleteExecute(r)
}

/*
ProductImageDelete product.image.delete

Delete image

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductImageDeleteRequest
*/
func (a *ProductAPIService) ProductImageDelete(ctx context.Context) ApiProductImageDeleteRequest {
	return ApiProductImageDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeDelete200Response
func (a *ProductAPIService) ProductImageDeleteExecute(r ApiProductImageDeleteRequest) (*AttributeDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductImageDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.image.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductImageUpdateRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	id *string
	variantIds *string
	imageName *string
	type_ *string
	label *string
	position *int32
	storeId *string
	langId *string
	hidden *bool
}

// Defines product id where the image should be updated
func (r ApiProductImageUpdateRequest) ProductId(productId string) ApiProductImageUpdateRequest {
	r.productId = &productId
	return r
}

// Defines image update specified by image id
func (r ApiProductImageUpdateRequest) Id(id string) ApiProductImageUpdateRequest {
	r.id = &id
	return r
}

// Defines product&#39;s variants ids
func (r ApiProductImageUpdateRequest) VariantIds(variantIds string) ApiProductImageUpdateRequest {
	r.variantIds = &variantIds
	return r
}

// Defines image&#39;s name
func (r ApiProductImageUpdateRequest) ImageName(imageName string) ApiProductImageUpdateRequest {
	r.imageName = &imageName
	return r
}

// Defines image&#39;s types that are specified by comma-separated list
func (r ApiProductImageUpdateRequest) Type_(type_ string) ApiProductImageUpdateRequest {
	r.type_ = &type_
	return r
}

// Defines alternative text that has to be attached to the picture
func (r ApiProductImageUpdateRequest) Label(label string) ApiProductImageUpdateRequest {
	r.label = &label
	return r
}

// Defines images position in the list
func (r ApiProductImageUpdateRequest) Position(position int32) ApiProductImageUpdateRequest {
	r.position = &position
	return r
}

// Store Id
func (r ApiProductImageUpdateRequest) StoreId(storeId string) ApiProductImageUpdateRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiProductImageUpdateRequest) LangId(langId string) ApiProductImageUpdateRequest {
	r.langId = &langId
	return r
}

// Define is hide image
func (r ApiProductImageUpdateRequest) Hidden(hidden bool) ApiProductImageUpdateRequest {
	r.hidden = &hidden
	return r
}

func (r ApiProductImageUpdateRequest) Execute() (*ProductImageUpdate200Response, *http.Response, error) {
	return r.ApiService.ProductImageUpdateExecute(r)
}

/*
ProductImageUpdate product.image.update

Update details of image

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductImageUpdateRequest
*/
func (a *ProductAPIService) ProductImageUpdate(ctx context.Context) ApiProductImageUpdateRequest {
	return ApiProductImageUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductImageUpdate200Response
func (a *ProductAPIService) ProductImageUpdateExecute(r ApiProductImageUpdateRequest) (*ProductImageUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductImageUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductImageUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.image.update.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	if r.variantIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "variant_ids", r.variantIds, "form", "")
	}
	if r.imageName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "image_name", r.imageName, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	} else {
		var defaultValue string = "additional"
		r.type_ = &defaultValue
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "form", "")
	}
	if r.position != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "position", r.position, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.hidden != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hidden", r.hidden, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductInfoRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	id *string
	params *string
	responseFields *string
	exclude *string
	storeId *string
	langId *string
	currencyId *string
	reportRequestId *string
	disableReportCache *bool
	useLatestApiVersion *bool
}

// Retrieves product&#39;s info specified by product id
func (r ApiProductInfoRequest) Id(id string) ApiProductInfoRequest {
	r.id = &id
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductInfoRequest) Params(params string) ApiProductInfoRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductInfoRequest) ResponseFields(responseFields string) ApiProductInfoRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiProductInfoRequest) Exclude(exclude string) ApiProductInfoRequest {
	r.exclude = &exclude
	return r
}

// Retrieves product info specified by store id
func (r ApiProductInfoRequest) StoreId(storeId string) ApiProductInfoRequest {
	r.storeId = &storeId
	return r
}

// Retrieves product info specified by language id
func (r ApiProductInfoRequest) LangId(langId string) ApiProductInfoRequest {
	r.langId = &langId
	return r
}

// Currency Id
func (r ApiProductInfoRequest) CurrencyId(currencyId string) ApiProductInfoRequest {
	r.currencyId = &currencyId
	return r
}

// Report request id
func (r ApiProductInfoRequest) ReportRequestId(reportRequestId string) ApiProductInfoRequest {
	r.reportRequestId = &reportRequestId
	return r
}

// Disable report cache for current request
func (r ApiProductInfoRequest) DisableReportCache(disableReportCache bool) ApiProductInfoRequest {
	r.disableReportCache = &disableReportCache
	return r
}

// Use the latest platform API version
func (r ApiProductInfoRequest) UseLatestApiVersion(useLatestApiVersion bool) ApiProductInfoRequest {
	r.useLatestApiVersion = &useLatestApiVersion
	return r
}

func (r ApiProductInfoRequest) Execute() (*ProductInfo200Response, *http.Response, error) {
	return r.ApiService.ProductInfoExecute(r)
}

/*
ProductInfo product.info

Get information about a specific product by its ID. In the case of a multistore configuration, use the store_id filter to get a response in the context of a specific store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductInfoRequest
*/
func (a *ProductAPIService) ProductInfo(ctx context.Context) ApiProductInfoRequest {
	return ApiProductInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductInfo200Response
func (a *ProductAPIService) ProductInfoExecute(r ApiProductInfoRequest) (*ProductInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.info.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,name,description,price,categories_ids"
		r.params = &defaultValue
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency_id", r.currencyId, "form", "")
	}
	if r.reportRequestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "report_request_id", r.reportRequestId, "form", "")
	}
	if r.disableReportCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_report_cache", r.disableReportCache, "form", "")
	} else {
		var defaultValue bool = false
		r.disableReportCache = &defaultValue
	}
	if r.useLatestApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_latest_api_version", r.useLatestApiVersion, "form", "")
	} else {
		var defaultValue bool = false
		r.useLatestApiVersion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductListRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	pageCursor *string
	start *int32
	count *int32
	params *string
	responseFields *string
	exclude *string
	categoryId *string
	createdFrom *string
	createdTo *string
	modifiedFrom *string
	modifiedTo *string
	availView *bool
	availSale *bool
	storeId *string
	langId *string
	currencyId *string
	productIds *string
	sinceId *string
	reportRequestId *string
	disableReportCache *bool
	sortBy *string
	sortDirection *string
	sku *string
	disableCache *bool
	brandName *string
	productAttributes *[]string
	status *string
	type_ *string
	findValue *string
	findWhere *string
	useLatestApiVersion *bool
	returnGlobal *bool
	categoriesIds *string
}

// Used to retrieve products via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiProductListRequest) PageCursor(pageCursor string) ApiProductListRequest {
	r.pageCursor = &pageCursor
	return r
}

// This parameter sets the number from which you want to get entities
func (r ApiProductListRequest) Start(start int32) ApiProductListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiProductListRequest) Count(count int32) ApiProductListRequest {
	r.count = &count
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductListRequest) Params(params string) ApiProductListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductListRequest) ResponseFields(responseFields string) ApiProductListRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiProductListRequest) Exclude(exclude string) ApiProductListRequest {
	r.exclude = &exclude
	return r
}

// Retrieves products specified by category id
func (r ApiProductListRequest) CategoryId(categoryId string) ApiProductListRequest {
	r.categoryId = &categoryId
	return r
}

// Retrieve entities from their creation date
func (r ApiProductListRequest) CreatedFrom(createdFrom string) ApiProductListRequest {
	r.createdFrom = &createdFrom
	return r
}

// Retrieve entities to their creation date
func (r ApiProductListRequest) CreatedTo(createdTo string) ApiProductListRequest {
	r.createdTo = &createdTo
	return r
}

// Retrieve entities from their modification date
func (r ApiProductListRequest) ModifiedFrom(modifiedFrom string) ApiProductListRequest {
	r.modifiedFrom = &modifiedFrom
	return r
}

// Retrieve entities to their modification date
func (r ApiProductListRequest) ModifiedTo(modifiedTo string) ApiProductListRequest {
	r.modifiedTo = &modifiedTo
	return r
}

// Specifies the set of visible/invisible products
func (r ApiProductListRequest) AvailView(availView bool) ApiProductListRequest {
	r.availView = &availView
	return r
}

// Specifies the set of available/not available products for sale
func (r ApiProductListRequest) AvailSale(availSale bool) ApiProductListRequest {
	r.availSale = &availSale
	return r
}

// Retrieves products specified by store id
func (r ApiProductListRequest) StoreId(storeId string) ApiProductListRequest {
	r.storeId = &storeId
	return r
}

// Retrieves products specified by language id
func (r ApiProductListRequest) LangId(langId string) ApiProductListRequest {
	r.langId = &langId
	return r
}

// Currency Id
func (r ApiProductListRequest) CurrencyId(currencyId string) ApiProductListRequest {
	r.currencyId = &currencyId
	return r
}

// Retrieves products specified by product ids
func (r ApiProductListRequest) ProductIds(productIds string) ApiProductListRequest {
	r.productIds = &productIds
	return r
}

// Retrieve entities starting from the specified id.
func (r ApiProductListRequest) SinceId(sinceId string) ApiProductListRequest {
	r.sinceId = &sinceId
	return r
}

// Report request id
func (r ApiProductListRequest) ReportRequestId(reportRequestId string) ApiProductListRequest {
	r.reportRequestId = &reportRequestId
	return r
}

// Disable report cache for current request
func (r ApiProductListRequest) DisableReportCache(disableReportCache bool) ApiProductListRequest {
	r.disableReportCache = &disableReportCache
	return r
}

// Set field to sort by
func (r ApiProductListRequest) SortBy(sortBy string) ApiProductListRequest {
	r.sortBy = &sortBy
	return r
}

// Set sorting direction
func (r ApiProductListRequest) SortDirection(sortDirection string) ApiProductListRequest {
	r.sortDirection = &sortDirection
	return r
}

// Filter by product&#39;s sku
func (r ApiProductListRequest) Sku(sku string) ApiProductListRequest {
	r.sku = &sku
	return r
}

// Disable cache for current request
func (r ApiProductListRequest) DisableCache(disableCache bool) ApiProductListRequest {
	r.disableCache = &disableCache
	return r
}

// Retrieves brands specified by brand name
func (r ApiProductListRequest) BrandName(brandName string) ApiProductListRequest {
	r.brandName = &brandName
	return r
}

// Defines product attributes
func (r ApiProductListRequest) ProductAttributes(productAttributes []string) ApiProductListRequest {
	r.productAttributes = &productAttributes
	return r
}

// Defines product&#39;s status
func (r ApiProductListRequest) Status(status string) ApiProductListRequest {
	r.status = &status
	return r
}

// Defines products&#39;s type
func (r ApiProductListRequest) Type_(type_ string) ApiProductListRequest {
	r.type_ = &type_
	return r
}

// Entity search that is specified by some value
func (r ApiProductListRequest) FindValue(findValue string) ApiProductListRequest {
	r.findValue = &findValue
	return r
}

// Product search that is specified by field
func (r ApiProductListRequest) FindWhere(findWhere string) ApiProductListRequest {
	r.findWhere = &findWhere
	return r
}

// Use the latest platform API version
func (r ApiProductListRequest) UseLatestApiVersion(useLatestApiVersion bool) ApiProductListRequest {
	r.useLatestApiVersion = &useLatestApiVersion
	return r
}

// Determines the type of products to be returned. If set to &#39;true&#39;, only global products will be returned; if set to &#39;false&#39;, only local products will be returned.
func (r ApiProductListRequest) ReturnGlobal(returnGlobal bool) ApiProductListRequest {
	r.returnGlobal = &returnGlobal
	return r
}

// Retrieves products specified by categories ids
func (r ApiProductListRequest) CategoriesIds(categoriesIds string) ApiProductListRequest {
	r.categoriesIds = &categoriesIds
	return r
}

func (r ApiProductListRequest) Execute() (*ModelResponseProductList, *http.Response, error) {
	return r.ApiService.ProductListExecute(r)
}

/*
ProductList product.list

Get list of products from your store. Returns 10 products by default.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductListRequest
*/
func (a *ProductAPIService) ProductList(ctx context.Context) ApiProductListRequest {
	return ApiProductListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseProductList
func (a *ProductAPIService) ProductListExecute(r ApiProductListRequest) (*ModelResponseProductList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseProductList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,name,description,price,categories_ids"
		r.params = &defaultValue
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.categoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category_id", r.categoryId, "form", "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from", r.createdFrom, "form", "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to", r.createdTo, "form", "")
	}
	if r.modifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from", r.modifiedFrom, "form", "")
	}
	if r.modifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to", r.modifiedTo, "form", "")
	}
	if r.availView != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avail_view", r.availView, "form", "")
	}
	if r.availSale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "avail_sale", r.availSale, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency_id", r.currencyId, "form", "")
	}
	if r.productIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_ids", r.productIds, "form", "")
	}
	if r.sinceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_id", r.sinceId, "form", "")
	}
	if r.reportRequestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "report_request_id", r.reportRequestId, "form", "")
	}
	if r.disableReportCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_report_cache", r.disableReportCache, "form", "")
	} else {
		var defaultValue bool = false
		r.disableReportCache = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	} else {
		var defaultValue string = "id"
		r.sortBy = &defaultValue
	}
	if r.sortDirection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_direction", r.sortDirection, "form", "")
	} else {
		var defaultValue string = "asc"
		r.sortDirection = &defaultValue
	}
	if r.sku != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sku", r.sku, "form", "")
	}
	if r.disableCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_cache", r.disableCache, "form", "")
	} else {
		var defaultValue bool = false
		r.disableCache = &defaultValue
	}
	if r.brandName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "brand_name", r.brandName, "form", "")
	}
	if r.productAttributes != nil {
		t := *r.productAttributes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "product_attributes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "product_attributes", t, "form", "multi")
		}
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.findValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_value", r.findValue, "form", "")
	}
	if r.findWhere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_where", r.findWhere, "form", "")
	}
	if r.useLatestApiVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "use_latest_api_version", r.useLatestApiVersion, "form", "")
	} else {
		var defaultValue bool = false
		r.useLatestApiVersion = &defaultValue
	}
	if r.returnGlobal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "return_global", r.returnGlobal, "form", "")
	} else {
		var defaultValue bool = false
		r.returnGlobal = &defaultValue
	}
	if r.categoriesIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "categories_ids", r.categoriesIds, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductManufacturerAddRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	manufacturer *string
	storeId *string
}

// Defines products specified by product id
func (r ApiProductManufacturerAddRequest) ProductId(productId string) ApiProductManufacturerAddRequest {
	r.productId = &productId
	return r
}

// Defines products manufacturer&#39;s name
func (r ApiProductManufacturerAddRequest) Manufacturer(manufacturer string) ApiProductManufacturerAddRequest {
	r.manufacturer = &manufacturer
	return r
}

// Store Id
func (r ApiProductManufacturerAddRequest) StoreId(storeId string) ApiProductManufacturerAddRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductManufacturerAddRequest) Execute() (*ProductManufacturerAdd200Response, *http.Response, error) {
	return r.ApiService.ProductManufacturerAddExecute(r)
}

/*
ProductManufacturerAdd product.manufacturer.add

Add manufacturer to store and assign to product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductManufacturerAddRequest
*/
func (a *ProductAPIService) ProductManufacturerAdd(ctx context.Context) ApiProductManufacturerAddRequest {
	return ApiProductManufacturerAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductManufacturerAdd200Response
func (a *ProductAPIService) ProductManufacturerAddExecute(r ApiProductManufacturerAddRequest) (*ProductManufacturerAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductManufacturerAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductManufacturerAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.manufacturer.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.manufacturer == nil {
		return localVarReturnValue, nil, reportError("manufacturer is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "manufacturer", r.manufacturer, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductOptionAddRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productOptionAdd *ProductOptionAdd
}

func (r ApiProductOptionAddRequest) ProductOptionAdd(productOptionAdd ProductOptionAdd) ApiProductOptionAddRequest {
	r.productOptionAdd = &productOptionAdd
	return r
}

func (r ApiProductOptionAddRequest) Execute() (*ProductOptionAdd200Response, *http.Response, error) {
	return r.ApiService.ProductOptionAddExecute(r)
}

/*
ProductOptionAdd product.option.add

Add product option from store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductOptionAddRequest
*/
func (a *ProductAPIService) ProductOptionAdd(ctx context.Context) ApiProductOptionAddRequest {
	return ApiProductOptionAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductOptionAdd200Response
func (a *ProductAPIService) ProductOptionAddExecute(r ApiProductOptionAddRequest) (*ProductOptionAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductOptionAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductOptionAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.option.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productOptionAdd == nil {
		return localVarReturnValue, nil, reportError("productOptionAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productOptionAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductOptionAssignRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	optionId *string
	required *bool
	sortOrder *int32
	optionValues *string
	clearCache *bool
}

// Defines product id where the option should be assigned
func (r ApiProductOptionAssignRequest) ProductId(productId string) ApiProductOptionAssignRequest {
	r.productId = &productId
	return r
}

// Defines option id which has to be assigned
func (r ApiProductOptionAssignRequest) OptionId(optionId string) ApiProductOptionAssignRequest {
	r.optionId = &optionId
	return r
}

// Defines if the option is required
func (r ApiProductOptionAssignRequest) Required(required bool) ApiProductOptionAssignRequest {
	r.required = &required
	return r
}

// Sort number in the list
func (r ApiProductOptionAssignRequest) SortOrder(sortOrder int32) ApiProductOptionAssignRequest {
	r.sortOrder = &sortOrder
	return r
}

// Defines option values that has to be assigned
func (r ApiProductOptionAssignRequest) OptionValues(optionValues string) ApiProductOptionAssignRequest {
	r.optionValues = &optionValues
	return r
}

// Is cache clear required
func (r ApiProductOptionAssignRequest) ClearCache(clearCache bool) ApiProductOptionAssignRequest {
	r.clearCache = &clearCache
	return r
}

func (r ApiProductOptionAssignRequest) Execute() (*ProductOptionAssign200Response, *http.Response, error) {
	return r.ApiService.ProductOptionAssignExecute(r)
}

/*
ProductOptionAssign product.option.assign

Assign option from product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductOptionAssignRequest
*/
func (a *ProductAPIService) ProductOptionAssign(ctx context.Context) ApiProductOptionAssignRequest {
	return ApiProductOptionAssignRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductOptionAssign200Response
func (a *ProductAPIService) ProductOptionAssignExecute(r ApiProductOptionAssignRequest) (*ProductOptionAssign200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductOptionAssign200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductOptionAssign")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.option.assign.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.optionId == nil {
		return localVarReturnValue, nil, reportError("optionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "option_id", r.optionId, "form", "")
	if r.required != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "required", r.required, "form", "")
	} else {
		var defaultValue bool = false
		r.required = &defaultValue
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "form", "")
	} else {
		var defaultValue int32 = 0
		r.sortOrder = &defaultValue
	}
	if r.optionValues != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "option_values", r.optionValues, "form", "")
	}
	if r.clearCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clear_cache", r.clearCache, "form", "")
	} else {
		var defaultValue bool = true
		r.clearCache = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductOptionDeleteRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	optionId *string
	productId *string
	storeId *string
}

// Defines option id that should be deleted
func (r ApiProductOptionDeleteRequest) OptionId(optionId string) ApiProductOptionDeleteRequest {
	r.optionId = &optionId
	return r
}

// Defines product id where the option should be deleted
func (r ApiProductOptionDeleteRequest) ProductId(productId string) ApiProductOptionDeleteRequest {
	r.productId = &productId
	return r
}

// Store Id
func (r ApiProductOptionDeleteRequest) StoreId(storeId string) ApiProductOptionDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductOptionDeleteRequest) Execute() (*AttributeDelete200Response, *http.Response, error) {
	return r.ApiService.ProductOptionDeleteExecute(r)
}

/*
ProductOptionDelete product.option.delete

Product option delete.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductOptionDeleteRequest
*/
func (a *ProductAPIService) ProductOptionDelete(ctx context.Context) ApiProductOptionDeleteRequest {
	return ApiProductOptionDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeDelete200Response
func (a *ProductAPIService) ProductOptionDeleteExecute(r ApiProductOptionDeleteRequest) (*AttributeDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductOptionDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.option.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.optionId == nil {
		return localVarReturnValue, nil, reportError("optionId is required and must be specified")
	}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "option_id", r.optionId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductOptionListRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	start *int32
	count *int32
	params *string
	exclude *string
	responseFields *string
	productId *string
	langId *string
	storeId *string
}

// This parameter sets the number from which you want to get entities
func (r ApiProductOptionListRequest) Start(start int32) ApiProductOptionListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiProductOptionListRequest) Count(count int32) ApiProductOptionListRequest {
	r.count = &count
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductOptionListRequest) Params(params string) ApiProductOptionListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiProductOptionListRequest) Exclude(exclude string) ApiProductOptionListRequest {
	r.exclude = &exclude
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductOptionListRequest) ResponseFields(responseFields string) ApiProductOptionListRequest {
	r.responseFields = &responseFields
	return r
}

// Retrieves products&#39; options specified by product id
func (r ApiProductOptionListRequest) ProductId(productId string) ApiProductOptionListRequest {
	r.productId = &productId
	return r
}

// Language id
func (r ApiProductOptionListRequest) LangId(langId string) ApiProductOptionListRequest {
	r.langId = &langId
	return r
}

// Store Id
func (r ApiProductOptionListRequest) StoreId(storeId string) ApiProductOptionListRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductOptionListRequest) Execute() (*ModelResponseProductOptionList, *http.Response, error) {
	return r.ApiService.ProductOptionListExecute(r)
}

/*
ProductOptionList product.option.list

Get list of options.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductOptionListRequest
*/
func (a *ProductAPIService) ProductOptionList(ctx context.Context) ApiProductOptionListRequest {
	return ApiProductOptionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseProductOptionList
func (a *ProductAPIService) ProductOptionListExecute(r ApiProductOptionListRequest) (*ModelResponseProductOptionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseProductOptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductOptionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.option.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,name,description"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductOptionValueAddRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	optionId *string
	optionValue *string
	sortOrder *int32
	displayValue *string
	isDefault *bool
	clearCache *bool
}

// Defines product id where the option value should be added
func (r ApiProductOptionValueAddRequest) ProductId(productId string) ApiProductOptionValueAddRequest {
	r.productId = &productId
	return r
}

// Defines option id where the value has to be added
func (r ApiProductOptionValueAddRequest) OptionId(optionId string) ApiProductOptionValueAddRequest {
	r.optionId = &optionId
	return r
}

// Defines option value that has to be added
func (r ApiProductOptionValueAddRequest) OptionValue(optionValue string) ApiProductOptionValueAddRequest {
	r.optionValue = &optionValue
	return r
}

// Sort number in the list
func (r ApiProductOptionValueAddRequest) SortOrder(sortOrder int32) ApiProductOptionValueAddRequest {
	r.sortOrder = &sortOrder
	return r
}

// Defines the value that will be displayed for the option value
func (r ApiProductOptionValueAddRequest) DisplayValue(displayValue string) ApiProductOptionValueAddRequest {
	r.displayValue = &displayValue
	return r
}

// Defines as a default
func (r ApiProductOptionValueAddRequest) IsDefault(isDefault bool) ApiProductOptionValueAddRequest {
	r.isDefault = &isDefault
	return r
}

// Is cache clear required
func (r ApiProductOptionValueAddRequest) ClearCache(clearCache bool) ApiProductOptionValueAddRequest {
	r.clearCache = &clearCache
	return r
}

func (r ApiProductOptionValueAddRequest) Execute() (*ProductOptionValueAdd200Response, *http.Response, error) {
	return r.ApiService.ProductOptionValueAddExecute(r)
}

/*
ProductOptionValueAdd product.option.value.add

Add product option item from option.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductOptionValueAddRequest
*/
func (a *ProductAPIService) ProductOptionValueAdd(ctx context.Context) ApiProductOptionValueAddRequest {
	return ApiProductOptionValueAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductOptionValueAdd200Response
func (a *ProductAPIService) ProductOptionValueAddExecute(r ApiProductOptionValueAddRequest) (*ProductOptionValueAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductOptionValueAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductOptionValueAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.option.value.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.optionId == nil {
		return localVarReturnValue, nil, reportError("optionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "option_id", r.optionId, "form", "")
	if r.optionValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "option_value", r.optionValue, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "form", "")
	} else {
		var defaultValue int32 = 0
		r.sortOrder = &defaultValue
	}
	if r.displayValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "display_value", r.displayValue, "form", "")
	}
	if r.isDefault != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_default", r.isDefault, "form", "")
	}
	if r.clearCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clear_cache", r.clearCache, "form", "")
	} else {
		var defaultValue bool = true
		r.clearCache = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductOptionValueAssignRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productOptionId *int32
	optionValueId *string
	clearCache *bool
}

// Defines product&#39;s option id where the value has to be assigned
func (r ApiProductOptionValueAssignRequest) ProductOptionId(productOptionId int32) ApiProductOptionValueAssignRequest {
	r.productOptionId = &productOptionId
	return r
}

// Defines value id that has to be assigned
func (r ApiProductOptionValueAssignRequest) OptionValueId(optionValueId string) ApiProductOptionValueAssignRequest {
	r.optionValueId = &optionValueId
	return r
}

// Is cache clear required
func (r ApiProductOptionValueAssignRequest) ClearCache(clearCache bool) ApiProductOptionValueAssignRequest {
	r.clearCache = &clearCache
	return r
}

func (r ApiProductOptionValueAssignRequest) Execute() (*ProductOptionValueAssign200Response, *http.Response, error) {
	return r.ApiService.ProductOptionValueAssignExecute(r)
}

/*
ProductOptionValueAssign product.option.value.assign

Assign product option item from product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductOptionValueAssignRequest
*/
func (a *ProductAPIService) ProductOptionValueAssign(ctx context.Context) ApiProductOptionValueAssignRequest {
	return ApiProductOptionValueAssignRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductOptionValueAssign200Response
func (a *ProductAPIService) ProductOptionValueAssignExecute(r ApiProductOptionValueAssignRequest) (*ProductOptionValueAssign200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductOptionValueAssign200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductOptionValueAssign")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.option.value.assign.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productOptionId == nil {
		return localVarReturnValue, nil, reportError("productOptionId is required and must be specified")
	}
	if r.optionValueId == nil {
		return localVarReturnValue, nil, reportError("optionValueId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_option_id", r.productOptionId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "option_value_id", r.optionValueId, "form", "")
	if r.clearCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clear_cache", r.clearCache, "form", "")
	} else {
		var defaultValue bool = true
		r.clearCache = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductOptionValueDeleteRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	optionId *string
	optionValueId *string
	productId *string
	storeId *string
}

// Defines option id where the value should be deleted
func (r ApiProductOptionValueDeleteRequest) OptionId(optionId string) ApiProductOptionValueDeleteRequest {
	r.optionId = &optionId
	return r
}

// Defines option value id that should be deleted
func (r ApiProductOptionValueDeleteRequest) OptionValueId(optionValueId string) ApiProductOptionValueDeleteRequest {
	r.optionValueId = &optionValueId
	return r
}

// Defines product id where the option value should be deleted
func (r ApiProductOptionValueDeleteRequest) ProductId(productId string) ApiProductOptionValueDeleteRequest {
	r.productId = &productId
	return r
}

// Store Id
func (r ApiProductOptionValueDeleteRequest) StoreId(storeId string) ApiProductOptionValueDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductOptionValueDeleteRequest) Execute() (*AttributeDelete200Response, *http.Response, error) {
	return r.ApiService.ProductOptionValueDeleteExecute(r)
}

/*
ProductOptionValueDelete product.option.value.delete

Product option value delete.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductOptionValueDeleteRequest
*/
func (a *ProductAPIService) ProductOptionValueDelete(ctx context.Context) ApiProductOptionValueDeleteRequest {
	return ApiProductOptionValueDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeDelete200Response
func (a *ProductAPIService) ProductOptionValueDeleteExecute(r ApiProductOptionValueDeleteRequest) (*AttributeDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductOptionValueDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.option.value.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.optionId == nil {
		return localVarReturnValue, nil, reportError("optionId is required and must be specified")
	}
	if r.optionValueId == nil {
		return localVarReturnValue, nil, reportError("optionValueId is required and must be specified")
	}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "option_id", r.optionId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "option_value_id", r.optionValueId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductOptionValueUpdateRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	optionId *string
	optionValueId *string
	optionValue *string
	price *float32
	quantity *float32
	displayValue *string
	clearCache *bool
}

// Defines product id where the option value should be updated
func (r ApiProductOptionValueUpdateRequest) ProductId(productId string) ApiProductOptionValueUpdateRequest {
	r.productId = &productId
	return r
}

// Defines option id where the value has to be updated
func (r ApiProductOptionValueUpdateRequest) OptionId(optionId string) ApiProductOptionValueUpdateRequest {
	r.optionId = &optionId
	return r
}

// Defines value id that has to be assigned
func (r ApiProductOptionValueUpdateRequest) OptionValueId(optionValueId string) ApiProductOptionValueUpdateRequest {
	r.optionValueId = &optionValueId
	return r
}

// Defines option value that has to be added
func (r ApiProductOptionValueUpdateRequest) OptionValue(optionValue string) ApiProductOptionValueUpdateRequest {
	r.optionValue = &optionValue
	return r
}

// Defines new product option price
func (r ApiProductOptionValueUpdateRequest) Price(price float32) ApiProductOptionValueUpdateRequest {
	r.price = &price
	return r
}

// Defines new products&#39; options quantity
func (r ApiProductOptionValueUpdateRequest) Quantity(quantity float32) ApiProductOptionValueUpdateRequest {
	r.quantity = &quantity
	return r
}

// Defines the value that will be displayed for the option value
func (r ApiProductOptionValueUpdateRequest) DisplayValue(displayValue string) ApiProductOptionValueUpdateRequest {
	r.displayValue = &displayValue
	return r
}

// Is cache clear required
func (r ApiProductOptionValueUpdateRequest) ClearCache(clearCache bool) ApiProductOptionValueUpdateRequest {
	r.clearCache = &clearCache
	return r
}

func (r ApiProductOptionValueUpdateRequest) Execute() (*AccountConfigUpdate200Response, *http.Response, error) {
	return r.ApiService.ProductOptionValueUpdateExecute(r)
}

/*
ProductOptionValueUpdate product.option.value.update

Update product option item from option.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductOptionValueUpdateRequest
*/
func (a *ProductAPIService) ProductOptionValueUpdate(ctx context.Context) ApiProductOptionValueUpdateRequest {
	return ApiProductOptionValueUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountConfigUpdate200Response
func (a *ProductAPIService) ProductOptionValueUpdateExecute(r ApiProductOptionValueUpdateRequest) (*AccountConfigUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountConfigUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductOptionValueUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.option.value.update.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.optionId == nil {
		return localVarReturnValue, nil, reportError("optionId is required and must be specified")
	}
	if r.optionValueId == nil {
		return localVarReturnValue, nil, reportError("optionValueId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "option_id", r.optionId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "option_value_id", r.optionValueId, "form", "")
	if r.optionValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "option_value", r.optionValue, "form", "")
	}
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "price", r.price, "form", "")
	}
	if r.quantity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quantity", r.quantity, "form", "")
	}
	if r.displayValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "display_value", r.displayValue, "form", "")
	}
	if r.clearCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clear_cache", r.clearCache, "form", "")
	} else {
		var defaultValue bool = true
		r.clearCache = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductPriceAddRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productPriceAdd *ProductPriceAdd
}

func (r ApiProductPriceAddRequest) ProductPriceAdd(productPriceAdd ProductPriceAdd) ApiProductPriceAddRequest {
	r.productPriceAdd = &productPriceAdd
	return r
}

func (r ApiProductPriceAddRequest) Execute() (*CartValidate200Response, *http.Response, error) {
	return r.ApiService.ProductPriceAddExecute(r)
}

/*
ProductPriceAdd product.price.add

Add some prices to the product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductPriceAddRequest
*/
func (a *ProductAPIService) ProductPriceAdd(ctx context.Context) ApiProductPriceAddRequest {
	return ApiProductPriceAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartValidate200Response
func (a *ProductAPIService) ProductPriceAddExecute(r ApiProductPriceAddRequest) (*CartValidate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartValidate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductPriceAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.price.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productPriceAdd == nil {
		return localVarReturnValue, nil, reportError("productPriceAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productPriceAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductPriceDeleteRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	groupPrices *string
	storeId *string
}

// Defines the product where the price has to be deleted
func (r ApiProductPriceDeleteRequest) ProductId(productId string) ApiProductPriceDeleteRequest {
	r.productId = &productId
	return r
}

// Defines product&#39;s group prices
func (r ApiProductPriceDeleteRequest) GroupPrices(groupPrices string) ApiProductPriceDeleteRequest {
	r.groupPrices = &groupPrices
	return r
}

// Store Id
func (r ApiProductPriceDeleteRequest) StoreId(storeId string) ApiProductPriceDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductPriceDeleteRequest) Execute() (*AttributeDelete200Response, *http.Response, error) {
	return r.ApiService.ProductPriceDeleteExecute(r)
}

/*
ProductPriceDelete product.price.delete

Delete some prices of the product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductPriceDeleteRequest
*/
func (a *ProductAPIService) ProductPriceDelete(ctx context.Context) ApiProductPriceDeleteRequest {
	return ApiProductPriceDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeDelete200Response
func (a *ProductAPIService) ProductPriceDeleteExecute(r ApiProductPriceDeleteRequest) (*AttributeDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductPriceDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.price.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	if r.groupPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_prices", r.groupPrices, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductPriceUpdateRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productPriceUpdate *ProductPriceUpdate
}

func (r ApiProductPriceUpdateRequest) ProductPriceUpdate(productPriceUpdate ProductPriceUpdate) ApiProductPriceUpdateRequest {
	r.productPriceUpdate = &productPriceUpdate
	return r
}

func (r ApiProductPriceUpdateRequest) Execute() (*AccountConfigUpdate200Response, *http.Response, error) {
	return r.ApiService.ProductPriceUpdateExecute(r)
}

/*
ProductPriceUpdate product.price.update

Update some prices of the product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductPriceUpdateRequest
*/
func (a *ProductAPIService) ProductPriceUpdate(ctx context.Context) ApiProductPriceUpdateRequest {
	return ApiProductPriceUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountConfigUpdate200Response
func (a *ProductAPIService) ProductPriceUpdateExecute(r ApiProductPriceUpdateRequest) (*AccountConfigUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountConfigUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductPriceUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.price.update.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productPriceUpdate == nil {
		return localVarReturnValue, nil, reportError("productPriceUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productPriceUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductReviewListRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	start *int32
	pageCursor *string
	count *int32
	ids *string
	storeId *string
	status *string
	params *string
	exclude *string
	responseFields *string
}

// Product id
func (r ApiProductReviewListRequest) ProductId(productId string) ApiProductReviewListRequest {
	r.productId = &productId
	return r
}

// This parameter sets the number from which you want to get entities
func (r ApiProductReviewListRequest) Start(start int32) ApiProductReviewListRequest {
	r.start = &start
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiProductReviewListRequest) PageCursor(pageCursor string) ApiProductReviewListRequest {
	r.pageCursor = &pageCursor
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiProductReviewListRequest) Count(count int32) ApiProductReviewListRequest {
	r.count = &count
	return r
}

// Retrieves reviews specified by ids
func (r ApiProductReviewListRequest) Ids(ids string) ApiProductReviewListRequest {
	r.ids = &ids
	return r
}

// Store Id
func (r ApiProductReviewListRequest) StoreId(storeId string) ApiProductReviewListRequest {
	r.storeId = &storeId
	return r
}

// Defines status
func (r ApiProductReviewListRequest) Status(status string) ApiProductReviewListRequest {
	r.status = &status
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductReviewListRequest) Params(params string) ApiProductReviewListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiProductReviewListRequest) Exclude(exclude string) ApiProductReviewListRequest {
	r.exclude = &exclude
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductReviewListRequest) ResponseFields(responseFields string) ApiProductReviewListRequest {
	r.responseFields = &responseFields
	return r
}

func (r ApiProductReviewListRequest) Execute() (*ModelResponseProductReviewList, *http.Response, error) {
	return r.ApiService.ProductReviewListExecute(r)
}

/*
ProductReviewList product.review.list

Get reviews of a specific product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductReviewListRequest
*/
func (a *ProductAPIService) ProductReviewList(ctx context.Context) ApiProductReviewListRequest {
	return ApiProductReviewListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseProductReviewList
func (a *ProductAPIService) ProductReviewListExecute(r ApiProductReviewListRequest) (*ModelResponseProductReviewList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseProductReviewList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductReviewList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.review.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,customer_id,email,message,status,product_id,nick_name,summary,rating,ratings,status,created_time"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductStoreAssignRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	storeId *string
}

// Defines id of the product which should be assigned to a store
func (r ApiProductStoreAssignRequest) ProductId(productId string) ApiProductStoreAssignRequest {
	r.productId = &productId
	return r
}

// Defines id of the store product should be assigned to
func (r ApiProductStoreAssignRequest) StoreId(storeId string) ApiProductStoreAssignRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductStoreAssignRequest) Execute() (*AccountConfigUpdate200Response, *http.Response, error) {
	return r.ApiService.ProductStoreAssignExecute(r)
}

/*
ProductStoreAssign product.store.assign

Assign product to store

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductStoreAssignRequest
*/
func (a *ProductAPIService) ProductStoreAssign(ctx context.Context) ApiProductStoreAssignRequest {
	return ApiProductStoreAssignRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountConfigUpdate200Response
func (a *ProductAPIService) ProductStoreAssignExecute(r ApiProductStoreAssignRequest) (*AccountConfigUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountConfigUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductStoreAssign")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.store.assign.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.storeId == nil {
		return localVarReturnValue, nil, reportError("storeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductTaxAddRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productTaxAdd *ProductTaxAdd
}

func (r ApiProductTaxAddRequest) ProductTaxAdd(productTaxAdd ProductTaxAdd) ApiProductTaxAddRequest {
	r.productTaxAdd = &productTaxAdd
	return r
}

func (r ApiProductTaxAddRequest) Execute() (*ProductTaxAdd200Response, *http.Response, error) {
	return r.ApiService.ProductTaxAddExecute(r)
}

/*
ProductTaxAdd product.tax.add

Add tax class and tax rate to store and assign to product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductTaxAddRequest
*/
func (a *ProductAPIService) ProductTaxAdd(ctx context.Context) ApiProductTaxAddRequest {
	return ApiProductTaxAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductTaxAdd200Response
func (a *ProductAPIService) ProductTaxAddExecute(r ApiProductTaxAddRequest) (*ProductTaxAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductTaxAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductTaxAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.tax.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productTaxAdd == nil {
		return localVarReturnValue, nil, reportError("productTaxAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productTaxAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductUpdateRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productUpdate *ProductUpdate
}

func (r ApiProductUpdateRequest) ProductUpdate(productUpdate ProductUpdate) ApiProductUpdateRequest {
	r.productUpdate = &productUpdate
	return r
}

func (r ApiProductUpdateRequest) Execute() (*AccountConfigUpdate200Response, *http.Response, error) {
	return r.ApiService.ProductUpdateExecute(r)
}

/*
ProductUpdate product.update

This method can be used to update certain product data. The list of supported parameters depends on the specific platform. Please transmit only those parameters that are supported by the particular platform. Please note that to update the product quantity, it is recommended to use relative parameters (increase_quantity or reduce_quantity) to avoid unexpected overwrites on heavily loaded stores.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductUpdateRequest
*/
func (a *ProductAPIService) ProductUpdate(ctx context.Context) ApiProductUpdateRequest {
	return ApiProductUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountConfigUpdate200Response
func (a *ProductAPIService) ProductUpdateExecute(r ApiProductUpdateRequest) (*AccountConfigUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountConfigUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.update.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productUpdate == nil {
		return localVarReturnValue, nil, reportError("productUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductUpdateBatchRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productUpdateBatch *ProductUpdateBatch
}

func (r ApiProductUpdateBatchRequest) ProductUpdateBatch(productUpdateBatch ProductUpdateBatch) ApiProductUpdateBatchRequest {
	r.productUpdateBatch = &productUpdateBatch
	return r
}

func (r ApiProductUpdateBatchRequest) Execute() (*CategoryAddBatch200Response, *http.Response, error) {
	return r.ApiService.ProductUpdateBatchExecute(r)
}

/*
ProductUpdateBatch product.update.batch

Update products on the store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductUpdateBatchRequest
*/
func (a *ProductAPIService) ProductUpdateBatch(ctx context.Context) ApiProductUpdateBatchRequest {
	return ApiProductUpdateBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CategoryAddBatch200Response
func (a *ProductAPIService) ProductUpdateBatchExecute(r ApiProductUpdateBatchRequest) (*CategoryAddBatch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryAddBatch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductUpdateBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.update.batch.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productUpdateBatch == nil {
		return localVarReturnValue, nil, reportError("productUpdateBatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productUpdateBatch
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantAddRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productVariantAdd *ProductVariantAdd
}

func (r ApiProductVariantAddRequest) ProductVariantAdd(productVariantAdd ProductVariantAdd) ApiProductVariantAddRequest {
	r.productVariantAdd = &productVariantAdd
	return r
}

func (r ApiProductVariantAddRequest) Execute() (*ProductVariantAdd200Response, *http.Response, error) {
	return r.ApiService.ProductVariantAddExecute(r)
}

/*
ProductVariantAdd product.variant.add

Add variant to product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantAddRequest
*/
func (a *ProductAPIService) ProductVariantAdd(ctx context.Context) ApiProductVariantAddRequest {
	return ApiProductVariantAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductVariantAdd200Response
func (a *ProductAPIService) ProductVariantAddExecute(r ApiProductVariantAddRequest) (*ProductVariantAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductVariantAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productVariantAdd == nil {
		return localVarReturnValue, nil, reportError("productVariantAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productVariantAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantAddBatchRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productVariantAddBatch *ProductVariantAddBatch
}

func (r ApiProductVariantAddBatchRequest) ProductVariantAddBatch(productVariantAddBatch ProductVariantAddBatch) ApiProductVariantAddBatchRequest {
	r.productVariantAddBatch = &productVariantAddBatch
	return r
}

func (r ApiProductVariantAddBatchRequest) Execute() (*CategoryAddBatch200Response, *http.Response, error) {
	return r.ApiService.ProductVariantAddBatchExecute(r)
}

/*
ProductVariantAddBatch product.variant.add.batch

Add new product variants to the store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantAddBatchRequest
*/
func (a *ProductAPIService) ProductVariantAddBatch(ctx context.Context) ApiProductVariantAddBatchRequest {
	return ApiProductVariantAddBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CategoryAddBatch200Response
func (a *ProductAPIService) ProductVariantAddBatchExecute(r ApiProductVariantAddBatchRequest) (*CategoryAddBatch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryAddBatch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantAddBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.add.batch.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productVariantAddBatch == nil {
		return localVarReturnValue, nil, reportError("productVariantAddBatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productVariantAddBatch
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantCountRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	createdFrom *string
	createdTo *string
	modifiedFrom *string
	modifiedTo *string
	categoryId *string
	storeId *string
}

// Retrieves products&#39; variants specified by product id
func (r ApiProductVariantCountRequest) ProductId(productId string) ApiProductVariantCountRequest {
	r.productId = &productId
	return r
}

// Retrieve entities from their creation date
func (r ApiProductVariantCountRequest) CreatedFrom(createdFrom string) ApiProductVariantCountRequest {
	r.createdFrom = &createdFrom
	return r
}

// Retrieve entities to their creation date
func (r ApiProductVariantCountRequest) CreatedTo(createdTo string) ApiProductVariantCountRequest {
	r.createdTo = &createdTo
	return r
}

// Retrieve entities from their modification date
func (r ApiProductVariantCountRequest) ModifiedFrom(modifiedFrom string) ApiProductVariantCountRequest {
	r.modifiedFrom = &modifiedFrom
	return r
}

// Retrieve entities to their modification date
func (r ApiProductVariantCountRequest) ModifiedTo(modifiedTo string) ApiProductVariantCountRequest {
	r.modifiedTo = &modifiedTo
	return r
}

// Counts products variants specified by category id
func (r ApiProductVariantCountRequest) CategoryId(categoryId string) ApiProductVariantCountRequest {
	r.categoryId = &categoryId
	return r
}

// Retrieves variants specified by store id
func (r ApiProductVariantCountRequest) StoreId(storeId string) ApiProductVariantCountRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductVariantCountRequest) Execute() (*ProductVariantCount200Response, *http.Response, error) {
	return r.ApiService.ProductVariantCountExecute(r)
}

/*
ProductVariantCount product.variant.count

Get count variants.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantCountRequest

Deprecated
*/
func (a *ProductAPIService) ProductVariantCount(ctx context.Context) ApiProductVariantCountRequest {
	return ApiProductVariantCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductVariantCount200Response
// Deprecated
func (a *ProductAPIService) ProductVariantCountExecute(r ApiProductVariantCountRequest) (*ProductVariantCount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductVariantCount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.count.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}

	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from", r.createdFrom, "form", "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to", r.createdTo, "form", "")
	}
	if r.modifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from", r.modifiedFrom, "form", "")
	}
	if r.modifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to", r.modifiedTo, "form", "")
	}
	if r.categoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category_id", r.categoryId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantDeleteRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	id *string
	productId *string
	storeId *string
}

// Defines variant removal, specified by variant id
func (r ApiProductVariantDeleteRequest) Id(id string) ApiProductVariantDeleteRequest {
	r.id = &id
	return r
}

// Defines product&#39;s id where the variant has to be deleted
func (r ApiProductVariantDeleteRequest) ProductId(productId string) ApiProductVariantDeleteRequest {
	r.productId = &productId
	return r
}

// Store Id
func (r ApiProductVariantDeleteRequest) StoreId(storeId string) ApiProductVariantDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductVariantDeleteRequest) Execute() (*AttributeValueDelete200Response, *http.Response, error) {
	return r.ApiService.ProductVariantDeleteExecute(r)
}

/*
ProductVariantDelete product.variant.delete

Delete variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantDeleteRequest
*/
func (a *ProductAPIService) ProductVariantDelete(ctx context.Context) ApiProductVariantDeleteRequest {
	return ApiProductVariantDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeValueDelete200Response
func (a *ProductAPIService) ProductVariantDeleteExecute(r ApiProductVariantDeleteRequest) (*AttributeValueDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeValueDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantDeleteBatchRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productVariantDeleteBatch *ProductVariantDeleteBatch
}

func (r ApiProductVariantDeleteBatchRequest) ProductVariantDeleteBatch(productVariantDeleteBatch ProductVariantDeleteBatch) ApiProductVariantDeleteBatchRequest {
	r.productVariantDeleteBatch = &productVariantDeleteBatch
	return r
}

func (r ApiProductVariantDeleteBatchRequest) Execute() (*CategoryAddBatch200Response, *http.Response, error) {
	return r.ApiService.ProductVariantDeleteBatchExecute(r)
}

/*
ProductVariantDeleteBatch product.variant.delete.batch

Remove product variants from the store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantDeleteBatchRequest
*/
func (a *ProductAPIService) ProductVariantDeleteBatch(ctx context.Context) ApiProductVariantDeleteBatchRequest {
	return ApiProductVariantDeleteBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CategoryAddBatch200Response
func (a *ProductAPIService) ProductVariantDeleteBatchExecute(r ApiProductVariantDeleteBatchRequest) (*CategoryAddBatch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryAddBatch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantDeleteBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.delete.batch.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productVariantDeleteBatch == nil {
		return localVarReturnValue, nil, reportError("productVariantDeleteBatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productVariantDeleteBatch
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantImageAddRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productVariantImageAdd *ProductVariantImageAdd
}

func (r ApiProductVariantImageAddRequest) ProductVariantImageAdd(productVariantImageAdd ProductVariantImageAdd) ApiProductVariantImageAddRequest {
	r.productVariantImageAdd = &productVariantImageAdd
	return r
}

func (r ApiProductVariantImageAddRequest) Execute() (*ProductVariantImageAdd200Response, *http.Response, error) {
	return r.ApiService.ProductVariantImageAddExecute(r)
}

/*
ProductVariantImageAdd product.variant.image.add

Add image to product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantImageAddRequest
*/
func (a *ProductAPIService) ProductVariantImageAdd(ctx context.Context) ApiProductVariantImageAddRequest {
	return ApiProductVariantImageAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductVariantImageAdd200Response
func (a *ProductAPIService) ProductVariantImageAddExecute(r ApiProductVariantImageAddRequest) (*ProductVariantImageAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductVariantImageAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantImageAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.image.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productVariantImageAdd == nil {
		return localVarReturnValue, nil, reportError("productVariantImageAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productVariantImageAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantImageDeleteRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productId *string
	productVariantId *string
	id *string
	storeId *string
}

// Defines product id where the variant image should be deleted
func (r ApiProductVariantImageDeleteRequest) ProductId(productId string) ApiProductVariantImageDeleteRequest {
	r.productId = &productId
	return r
}

// Defines product&#39;s variants specified by variant id
func (r ApiProductVariantImageDeleteRequest) ProductVariantId(productVariantId string) ApiProductVariantImageDeleteRequest {
	r.productVariantId = &productVariantId
	return r
}

// Entity id
func (r ApiProductVariantImageDeleteRequest) Id(id string) ApiProductVariantImageDeleteRequest {
	r.id = &id
	return r
}

// Store Id
func (r ApiProductVariantImageDeleteRequest) StoreId(storeId string) ApiProductVariantImageDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductVariantImageDeleteRequest) Execute() (*AttributeDelete200Response, *http.Response, error) {
	return r.ApiService.ProductVariantImageDeleteExecute(r)
}

/*
ProductVariantImageDelete product.variant.image.delete

Delete  image to product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantImageDeleteRequest
*/
func (a *ProductAPIService) ProductVariantImageDelete(ctx context.Context) ApiProductVariantImageDeleteRequest {
	return ApiProductVariantImageDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeDelete200Response
func (a *ProductAPIService) ProductVariantImageDeleteExecute(r ApiProductVariantImageDeleteRequest) (*AttributeDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantImageDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.image.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.productVariantId == nil {
		return localVarReturnValue, nil, reportError("productVariantId is required and must be specified")
	}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "product_variant_id", r.productVariantId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantInfoRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	id *string
	params *string
	exclude *string
	storeId *string
}

// Retrieves variant&#39;s info specified by variant id
func (r ApiProductVariantInfoRequest) Id(id string) ApiProductVariantInfoRequest {
	r.id = &id
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductVariantInfoRequest) Params(params string) ApiProductVariantInfoRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiProductVariantInfoRequest) Exclude(exclude string) ApiProductVariantInfoRequest {
	r.exclude = &exclude
	return r
}

// Retrieves variant info specified by store id
func (r ApiProductVariantInfoRequest) StoreId(storeId string) ApiProductVariantInfoRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductVariantInfoRequest) Execute() (*ProductInfo200Response, *http.Response, error) {
	return r.ApiService.ProductVariantInfoExecute(r)
}

/*
ProductVariantInfo product.variant.info

Get variant info. This method is deprecated, and its development is stopped. Please use "product.child_item.info" instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantInfoRequest

Deprecated
*/
func (a *ProductAPIService) ProductVariantInfo(ctx context.Context) ApiProductVariantInfoRequest {
	return ApiProductVariantInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductInfo200Response
// Deprecated
func (a *ProductAPIService) ProductVariantInfoExecute(r ApiProductVariantInfoRequest) (*ProductInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.info.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,name,description,price"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantListRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	start *int32
	count *int32
	params *string
	exclude *string
	createdFrom *string
	createdTo *string
	modifiedFrom *string
	modifiedTo *string
	categoryId *string
	productId *string
	storeId *string
}

// This parameter sets the number from which you want to get entities
func (r ApiProductVariantListRequest) Start(start int32) ApiProductVariantListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiProductVariantListRequest) Count(count int32) ApiProductVariantListRequest {
	r.count = &count
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiProductVariantListRequest) Params(params string) ApiProductVariantListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiProductVariantListRequest) Exclude(exclude string) ApiProductVariantListRequest {
	r.exclude = &exclude
	return r
}

// Retrieve entities from their creation date
func (r ApiProductVariantListRequest) CreatedFrom(createdFrom string) ApiProductVariantListRequest {
	r.createdFrom = &createdFrom
	return r
}

// Retrieve entities to their creation date
func (r ApiProductVariantListRequest) CreatedTo(createdTo string) ApiProductVariantListRequest {
	r.createdTo = &createdTo
	return r
}

// Retrieve entities from their modification date
func (r ApiProductVariantListRequest) ModifiedFrom(modifiedFrom string) ApiProductVariantListRequest {
	r.modifiedFrom = &modifiedFrom
	return r
}

// Retrieve entities to their modification date
func (r ApiProductVariantListRequest) ModifiedTo(modifiedTo string) ApiProductVariantListRequest {
	r.modifiedTo = &modifiedTo
	return r
}

// Retrieves products variants specified by category id
func (r ApiProductVariantListRequest) CategoryId(categoryId string) ApiProductVariantListRequest {
	r.categoryId = &categoryId
	return r
}

// Retrieves products&#39; variants specified by product id
func (r ApiProductVariantListRequest) ProductId(productId string) ApiProductVariantListRequest {
	r.productId = &productId
	return r
}

// Retrieves variants specified by store id
func (r ApiProductVariantListRequest) StoreId(storeId string) ApiProductVariantListRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductVariantListRequest) Execute() (*ProductVariantList200Response, *http.Response, error) {
	return r.ApiService.ProductVariantListExecute(r)
}

/*
ProductVariantList product.variant.list

Get a list of variants. This method is deprecated, and its development is stopped. Please use "product.child_item.list" instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantListRequest

Deprecated
*/
func (a *ProductAPIService) ProductVariantList(ctx context.Context) ApiProductVariantListRequest {
	return ApiProductVariantListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProductVariantList200Response
// Deprecated
func (a *ProductAPIService) ProductVariantListExecute(r ApiProductVariantListRequest) (*ProductVariantList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductVariantList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,name,description,price"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from", r.createdFrom, "form", "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to", r.createdTo, "form", "")
	}
	if r.modifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from", r.modifiedFrom, "form", "")
	}
	if r.modifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to", r.modifiedTo, "form", "")
	}
	if r.categoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category_id", r.categoryId, "form", "")
	}
	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantPriceAddRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productVariantPriceAdd *ProductVariantPriceAdd
}

func (r ApiProductVariantPriceAddRequest) ProductVariantPriceAdd(productVariantPriceAdd ProductVariantPriceAdd) ApiProductVariantPriceAddRequest {
	r.productVariantPriceAdd = &productVariantPriceAdd
	return r
}

func (r ApiProductVariantPriceAddRequest) Execute() (*CartValidate200Response, *http.Response, error) {
	return r.ApiService.ProductVariantPriceAddExecute(r)
}

/*
ProductVariantPriceAdd product.variant.price.add

Add some prices to the product variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantPriceAddRequest
*/
func (a *ProductAPIService) ProductVariantPriceAdd(ctx context.Context) ApiProductVariantPriceAddRequest {
	return ApiProductVariantPriceAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CartValidate200Response
func (a *ProductAPIService) ProductVariantPriceAddExecute(r ApiProductVariantPriceAddRequest) (*CartValidate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartValidate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantPriceAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.price.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productVariantPriceAdd == nil {
		return localVarReturnValue, nil, reportError("productVariantPriceAdd is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productVariantPriceAdd
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantPriceDeleteRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	id *string
	productId *string
	groupPrices *string
	storeId *string
}

// Defines the variant where the price has to be deleted
func (r ApiProductVariantPriceDeleteRequest) Id(id string) ApiProductVariantPriceDeleteRequest {
	r.id = &id
	return r
}

// Product id
func (r ApiProductVariantPriceDeleteRequest) ProductId(productId string) ApiProductVariantPriceDeleteRequest {
	r.productId = &productId
	return r
}

// Defines variants&#39;s group prices
func (r ApiProductVariantPriceDeleteRequest) GroupPrices(groupPrices string) ApiProductVariantPriceDeleteRequest {
	r.groupPrices = &groupPrices
	return r
}

// Store Id
func (r ApiProductVariantPriceDeleteRequest) StoreId(storeId string) ApiProductVariantPriceDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiProductVariantPriceDeleteRequest) Execute() (*AttributeDelete200Response, *http.Response, error) {
	return r.ApiService.ProductVariantPriceDeleteExecute(r)
}

/*
ProductVariantPriceDelete product.variant.price.delete

Delete some prices of the product variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantPriceDeleteRequest
*/
func (a *ProductAPIService) ProductVariantPriceDelete(ctx context.Context) ApiProductVariantPriceDeleteRequest {
	return ApiProductVariantPriceDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeDelete200Response
func (a *ProductAPIService) ProductVariantPriceDeleteExecute(r ApiProductVariantPriceDeleteRequest) (*AttributeDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantPriceDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.price.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.groupPrices == nil {
		return localVarReturnValue, nil, reportError("groupPrices is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "group_prices", r.groupPrices, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantPriceUpdateRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productVariantPriceUpdate *ProductVariantPriceUpdate
}

func (r ApiProductVariantPriceUpdateRequest) ProductVariantPriceUpdate(productVariantPriceUpdate ProductVariantPriceUpdate) ApiProductVariantPriceUpdateRequest {
	r.productVariantPriceUpdate = &productVariantPriceUpdate
	return r
}

func (r ApiProductVariantPriceUpdateRequest) Execute() (*AccountConfigUpdate200Response, *http.Response, error) {
	return r.ApiService.ProductVariantPriceUpdateExecute(r)
}

/*
ProductVariantPriceUpdate product.variant.price.update

Update some prices of the product variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantPriceUpdateRequest
*/
func (a *ProductAPIService) ProductVariantPriceUpdate(ctx context.Context) ApiProductVariantPriceUpdateRequest {
	return ApiProductVariantPriceUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountConfigUpdate200Response
func (a *ProductAPIService) ProductVariantPriceUpdateExecute(r ApiProductVariantPriceUpdateRequest) (*AccountConfigUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountConfigUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantPriceUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.price.update.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productVariantPriceUpdate == nil {
		return localVarReturnValue, nil, reportError("productVariantPriceUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productVariantPriceUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantUpdateRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productVariantUpdate *ProductVariantUpdate
}

func (r ApiProductVariantUpdateRequest) ProductVariantUpdate(productVariantUpdate ProductVariantUpdate) ApiProductVariantUpdateRequest {
	r.productVariantUpdate = &productVariantUpdate
	return r
}

func (r ApiProductVariantUpdateRequest) Execute() (*AccountConfigUpdate200Response, *http.Response, error) {
	return r.ApiService.ProductVariantUpdateExecute(r)
}

/*
ProductVariantUpdate product.variant.update

Update variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantUpdateRequest
*/
func (a *ProductAPIService) ProductVariantUpdate(ctx context.Context) ApiProductVariantUpdateRequest {
	return ApiProductVariantUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccountConfigUpdate200Response
func (a *ProductAPIService) ProductVariantUpdateExecute(r ApiProductVariantUpdateRequest) (*AccountConfigUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccountConfigUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.update.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productVariantUpdate == nil {
		return localVarReturnValue, nil, reportError("productVariantUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productVariantUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductVariantUpdateBatchRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	productVariantUpdateBatch *ProductVariantUpdateBatch
}

func (r ApiProductVariantUpdateBatchRequest) ProductVariantUpdateBatch(productVariantUpdateBatch ProductVariantUpdateBatch) ApiProductVariantUpdateBatchRequest {
	r.productVariantUpdateBatch = &productVariantUpdateBatch
	return r
}

func (r ApiProductVariantUpdateBatchRequest) Execute() (*CategoryAddBatch200Response, *http.Response, error) {
	return r.ApiService.ProductVariantUpdateBatchExecute(r)
}

/*
ProductVariantUpdateBatch product.variant.update.batch

Update products variants on the store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductVariantUpdateBatchRequest
*/
func (a *ProductAPIService) ProductVariantUpdateBatch(ctx context.Context) ApiProductVariantUpdateBatchRequest {
	return ApiProductVariantUpdateBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CategoryAddBatch200Response
func (a *ProductAPIService) ProductVariantUpdateBatchExecute(r ApiProductVariantUpdateBatchRequest) (*CategoryAddBatch200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryAddBatch200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductVariantUpdateBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product.variant.update.batch.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.productVariantUpdateBatch == nil {
		return localVarReturnValue, nil, reportError("productVariantUpdateBatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.productVariantUpdateBatch
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
