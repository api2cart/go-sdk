/*
API2Cart OpenAPI

API2Cart

API version: 1.1
Contact: contact@api2cart.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AttributeAPIService AttributeAPI service
type AttributeAPIService service

type ApiAttributeAddRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	type_ *string
	name *string
	code *string
	storeId *string
	langId *string
	visible *bool
	required *bool
	position *int32
	attributeGroupId *string
	isGlobal *string
	isSearchable *bool
	isFilterable *string
	isComparable *bool
	isHtmlAllowedOnFront *bool
	isFilterableInSearch *bool
	isConfigurable *bool
	isVisibleInAdvancedSearch *bool
	isUsedForPromoRules *bool
	usedInProductListing *bool
	usedForSortBy *bool
	applyTo *string
}

// Defines attribute&#39;s type
func (r ApiAttributeAddRequest) Type_(type_ string) ApiAttributeAddRequest {
	r.type_ = &type_
	return r
}

// Defines attributes&#39;s name
func (r ApiAttributeAddRequest) Name(name string) ApiAttributeAddRequest {
	r.name = &name
	return r
}

// Entity code
func (r ApiAttributeAddRequest) Code(code string) ApiAttributeAddRequest {
	r.code = &code
	return r
}

// Store Id
func (r ApiAttributeAddRequest) StoreId(storeId string) ApiAttributeAddRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiAttributeAddRequest) LangId(langId string) ApiAttributeAddRequest {
	r.langId = &langId
	return r
}

// Set visibility status
func (r ApiAttributeAddRequest) Visible(visible bool) ApiAttributeAddRequest {
	r.visible = &visible
	return r
}

// Defines if the option is required
func (r ApiAttributeAddRequest) Required(required bool) ApiAttributeAddRequest {
	r.required = &required
	return r
}

// Attribute&#x60;s position
func (r ApiAttributeAddRequest) Position(position int32) ApiAttributeAddRequest {
	r.position = &position
	return r
}

// Filter by attribute_group_id
func (r ApiAttributeAddRequest) AttributeGroupId(attributeGroupId string) ApiAttributeAddRequest {
	r.attributeGroupId = &attributeGroupId
	return r
}

// Attribute saving scope
func (r ApiAttributeAddRequest) IsGlobal(isGlobal string) ApiAttributeAddRequest {
	r.isGlobal = &isGlobal
	return r
}

// Use attribute in Quick Search
func (r ApiAttributeAddRequest) IsSearchable(isSearchable bool) ApiAttributeAddRequest {
	r.isSearchable = &isSearchable
	return r
}

// Use In Layered Navigation
func (r ApiAttributeAddRequest) IsFilterable(isFilterable string) ApiAttributeAddRequest {
	r.isFilterable = &isFilterable
	return r
}

// Comparable on Front-end
func (r ApiAttributeAddRequest) IsComparable(isComparable bool) ApiAttributeAddRequest {
	r.isComparable = &isComparable
	return r
}

// Allow HTML Tags on Frontend
func (r ApiAttributeAddRequest) IsHtmlAllowedOnFront(isHtmlAllowedOnFront bool) ApiAttributeAddRequest {
	r.isHtmlAllowedOnFront = &isHtmlAllowedOnFront
	return r
}

// Use In Search Results Layered Navigation
func (r ApiAttributeAddRequest) IsFilterableInSearch(isFilterableInSearch bool) ApiAttributeAddRequest {
	r.isFilterableInSearch = &isFilterableInSearch
	return r
}

// Use To Create Configurable Product
func (r ApiAttributeAddRequest) IsConfigurable(isConfigurable bool) ApiAttributeAddRequest {
	r.isConfigurable = &isConfigurable
	return r
}

// Use in Advanced Search
func (r ApiAttributeAddRequest) IsVisibleInAdvancedSearch(isVisibleInAdvancedSearch bool) ApiAttributeAddRequest {
	r.isVisibleInAdvancedSearch = &isVisibleInAdvancedSearch
	return r
}

// Use for Promo Rule Conditions
func (r ApiAttributeAddRequest) IsUsedForPromoRules(isUsedForPromoRules bool) ApiAttributeAddRequest {
	r.isUsedForPromoRules = &isUsedForPromoRules
	return r
}

// Used in Product Listing
func (r ApiAttributeAddRequest) UsedInProductListing(usedInProductListing bool) ApiAttributeAddRequest {
	r.usedInProductListing = &usedInProductListing
	return r
}

// Used for Sorting in Product Listing
func (r ApiAttributeAddRequest) UsedForSortBy(usedForSortBy bool) ApiAttributeAddRequest {
	r.usedForSortBy = &usedForSortBy
	return r
}

// Types of products which can have this attribute
func (r ApiAttributeAddRequest) ApplyTo(applyTo string) ApiAttributeAddRequest {
	r.applyTo = &applyTo
	return r
}

func (r ApiAttributeAddRequest) Execute() (*AttributeAdd200Response, *http.Response, error) {
	return r.ApiService.AttributeAddExecute(r)
}

/*
AttributeAdd attribute.add

Add new attribute

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeAddRequest
*/
func (a *AttributeAPIService) AttributeAdd(ctx context.Context) ApiAttributeAddRequest {
	return ApiAttributeAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeAdd200Response
func (a *AttributeAPIService) AttributeAddExecute(r ApiAttributeAddRequest) (*AttributeAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.visible != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visible", r.visible, "form", "")
	} else {
		var defaultValue bool = false
		r.visible = &defaultValue
	}
	if r.required != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "required", r.required, "form", "")
	} else {
		var defaultValue bool = false
		r.required = &defaultValue
	}
	if r.position != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "position", r.position, "form", "")
	} else {
		var defaultValue int32 = 0
		r.position = &defaultValue
	}
	if r.attributeGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_group_id", r.attributeGroupId, "form", "")
	}
	if r.isGlobal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_global", r.isGlobal, "form", "")
	} else {
		var defaultValue string = "Store"
		r.isGlobal = &defaultValue
	}
	if r.isSearchable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_searchable", r.isSearchable, "form", "")
	} else {
		var defaultValue bool = false
		r.isSearchable = &defaultValue
	}
	if r.isFilterable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_filterable", r.isFilterable, "form", "")
	} else {
		var defaultValue string = "No"
		r.isFilterable = &defaultValue
	}
	if r.isComparable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_comparable", r.isComparable, "form", "")
	} else {
		var defaultValue bool = false
		r.isComparable = &defaultValue
	}
	if r.isHtmlAllowedOnFront != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_html_allowed_on_front", r.isHtmlAllowedOnFront, "form", "")
	} else {
		var defaultValue bool = false
		r.isHtmlAllowedOnFront = &defaultValue
	}
	if r.isFilterableInSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_filterable_in_search", r.isFilterableInSearch, "form", "")
	} else {
		var defaultValue bool = false
		r.isFilterableInSearch = &defaultValue
	}
	if r.isConfigurable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_configurable", r.isConfigurable, "form", "")
	} else {
		var defaultValue bool = false
		r.isConfigurable = &defaultValue
	}
	if r.isVisibleInAdvancedSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_visible_in_advanced_search", r.isVisibleInAdvancedSearch, "form", "")
	} else {
		var defaultValue bool = false
		r.isVisibleInAdvancedSearch = &defaultValue
	}
	if r.isUsedForPromoRules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_used_for_promo_rules", r.isUsedForPromoRules, "form", "")
	} else {
		var defaultValue bool = false
		r.isUsedForPromoRules = &defaultValue
	}
	if r.usedInProductListing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "used_in_product_listing", r.usedInProductListing, "form", "")
	} else {
		var defaultValue bool = false
		r.usedInProductListing = &defaultValue
	}
	if r.usedForSortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "used_for_sort_by", r.usedForSortBy, "form", "")
	} else {
		var defaultValue bool = false
		r.usedForSortBy = &defaultValue
	}
	if r.applyTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apply_to", r.applyTo, "form", "")
	} else {
		var defaultValue string = "all_types"
		r.applyTo = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeAssignGroupRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	id *string
	groupId *string
	attributeSetId *string
}

// Entity id
func (r ApiAttributeAssignGroupRequest) Id(id string) ApiAttributeAssignGroupRequest {
	r.id = &id
	return r
}

// Attribute group_id
func (r ApiAttributeAssignGroupRequest) GroupId(groupId string) ApiAttributeAssignGroupRequest {
	r.groupId = &groupId
	return r
}

// Attribute set id
func (r ApiAttributeAssignGroupRequest) AttributeSetId(attributeSetId string) ApiAttributeAssignGroupRequest {
	r.attributeSetId = &attributeSetId
	return r
}

func (r ApiAttributeAssignGroupRequest) Execute() (*AttributeAssignGroup200Response, *http.Response, error) {
	return r.ApiService.AttributeAssignGroupExecute(r)
}

/*
AttributeAssignGroup attribute.assign.group

Assign attribute to the group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeAssignGroupRequest
*/
func (a *AttributeAPIService) AttributeAssignGroup(ctx context.Context) ApiAttributeAssignGroupRequest {
	return ApiAttributeAssignGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeAssignGroup200Response
func (a *AttributeAPIService) AttributeAssignGroupExecute(r ApiAttributeAssignGroupRequest) (*AttributeAssignGroup200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeAssignGroup200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeAssignGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.assign.group.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.groupId == nil {
		return localVarReturnValue, nil, reportError("groupId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", r.groupId, "form", "")
	if r.attributeSetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_set_id", r.attributeSetId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeAssignSetRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	id *string
	attributeSetId *string
	groupId *string
}

// Entity id
func (r ApiAttributeAssignSetRequest) Id(id string) ApiAttributeAssignSetRequest {
	r.id = &id
	return r
}

// Attribute set id
func (r ApiAttributeAssignSetRequest) AttributeSetId(attributeSetId string) ApiAttributeAssignSetRequest {
	r.attributeSetId = &attributeSetId
	return r
}

// Attribute group_id
func (r ApiAttributeAssignSetRequest) GroupId(groupId string) ApiAttributeAssignSetRequest {
	r.groupId = &groupId
	return r
}

func (r ApiAttributeAssignSetRequest) Execute() (*AttributeAssignGroup200Response, *http.Response, error) {
	return r.ApiService.AttributeAssignSetExecute(r)
}

/*
AttributeAssignSet attribute.assign.set

Assign attribute to the attribute set

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeAssignSetRequest
*/
func (a *AttributeAPIService) AttributeAssignSet(ctx context.Context) ApiAttributeAssignSetRequest {
	return ApiAttributeAssignSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeAssignGroup200Response
func (a *AttributeAPIService) AttributeAssignSetExecute(r ApiAttributeAssignSetRequest) (*AttributeAssignGroup200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeAssignGroup200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeAssignSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.assign.set.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.attributeSetId == nil {
		return localVarReturnValue, nil, reportError("attributeSetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", r.groupId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_set_id", r.attributeSetId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeAttributesetListRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	start *int32
	count *int32
	params *string
	exclude *string
	responseFields *string
}

// This parameter sets the number from which you want to get entities
func (r ApiAttributeAttributesetListRequest) Start(start int32) ApiAttributeAttributesetListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiAttributeAttributesetListRequest) Count(count int32) ApiAttributeAttributesetListRequest {
	r.count = &count
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiAttributeAttributesetListRequest) Params(params string) ApiAttributeAttributesetListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiAttributeAttributesetListRequest) Exclude(exclude string) ApiAttributeAttributesetListRequest {
	r.exclude = &exclude
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiAttributeAttributesetListRequest) ResponseFields(responseFields string) ApiAttributeAttributesetListRequest {
	r.responseFields = &responseFields
	return r
}

func (r ApiAttributeAttributesetListRequest) Execute() (*ModelResponseAttributeAttributesetList, *http.Response, error) {
	return r.ApiService.AttributeAttributesetListExecute(r)
}

/*
AttributeAttributesetList attribute.attributeset.list

Get attribute_set list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeAttributesetListRequest
*/
func (a *AttributeAPIService) AttributeAttributesetList(ctx context.Context) ApiAttributeAttributesetListRequest {
	return ApiAttributeAttributesetListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseAttributeAttributesetList
func (a *AttributeAPIService) AttributeAttributesetListExecute(r ApiAttributeAttributesetListRequest) (*ModelResponseAttributeAttributesetList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseAttributeAttributesetList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeAttributesetList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.attributeset.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,name"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeCountRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	type_ *string
	attributeSetId *string
	storeId *string
	langId *string
	visible *bool
	required *bool
	system *bool
}

// Defines attribute&#39;s type
func (r ApiAttributeCountRequest) Type_(type_ string) ApiAttributeCountRequest {
	r.type_ = &type_
	return r
}

// Filter items by attribute set id
func (r ApiAttributeCountRequest) AttributeSetId(attributeSetId string) ApiAttributeCountRequest {
	r.attributeSetId = &attributeSetId
	return r
}

// Store Id
func (r ApiAttributeCountRequest) StoreId(storeId string) ApiAttributeCountRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiAttributeCountRequest) LangId(langId string) ApiAttributeCountRequest {
	r.langId = &langId
	return r
}

// Filter items by visibility status
func (r ApiAttributeCountRequest) Visible(visible bool) ApiAttributeCountRequest {
	r.visible = &visible
	return r
}

// Defines if the option is required
func (r ApiAttributeCountRequest) Required(required bool) ApiAttributeCountRequest {
	r.required = &required
	return r
}

// True if attribute is system
func (r ApiAttributeCountRequest) System(system bool) ApiAttributeCountRequest {
	r.system = &system
	return r
}

func (r ApiAttributeCountRequest) Execute() (*AttributeCount200Response, *http.Response, error) {
	return r.ApiService.AttributeCountExecute(r)
}

/*
AttributeCount attribute.count

Get attributes count

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeCountRequest
*/
func (a *AttributeAPIService) AttributeCount(ctx context.Context) ApiAttributeCountRequest {
	return ApiAttributeCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeCount200Response
func (a *AttributeAPIService) AttributeCountExecute(r ApiAttributeCountRequest) (*AttributeCount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeCount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.count.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.attributeSetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_set_id", r.attributeSetId, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.visible != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visible", r.visible, "form", "")
	}
	if r.required != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "required", r.required, "form", "")
	}
	if r.system != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "system", r.system, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeDeleteRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	id *string
	storeId *string
}

// Entity id
func (r ApiAttributeDeleteRequest) Id(id string) ApiAttributeDeleteRequest {
	r.id = &id
	return r
}

// Store Id
func (r ApiAttributeDeleteRequest) StoreId(storeId string) ApiAttributeDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiAttributeDeleteRequest) Execute() (*AttributeDelete200Response, *http.Response, error) {
	return r.ApiService.AttributeDeleteExecute(r)
}

/*
AttributeDelete attribute.delete

Delete attribute from store

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeDeleteRequest
*/
func (a *AttributeAPIService) AttributeDelete(ctx context.Context) ApiAttributeDeleteRequest {
	return ApiAttributeDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeDelete200Response
func (a *AttributeAPIService) AttributeDeleteExecute(r ApiAttributeDeleteRequest) (*AttributeDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeGroupListRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	start *int32
	count *int32
	langId *string
	params *string
	exclude *string
	responseFields *string
	attributeSetId *string
}

// This parameter sets the number from which you want to get entities
func (r ApiAttributeGroupListRequest) Start(start int32) ApiAttributeGroupListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiAttributeGroupListRequest) Count(count int32) ApiAttributeGroupListRequest {
	r.count = &count
	return r
}

// Language id
func (r ApiAttributeGroupListRequest) LangId(langId string) ApiAttributeGroupListRequest {
	r.langId = &langId
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiAttributeGroupListRequest) Params(params string) ApiAttributeGroupListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiAttributeGroupListRequest) Exclude(exclude string) ApiAttributeGroupListRequest {
	r.exclude = &exclude
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiAttributeGroupListRequest) ResponseFields(responseFields string) ApiAttributeGroupListRequest {
	r.responseFields = &responseFields
	return r
}

// Attribute set id
func (r ApiAttributeGroupListRequest) AttributeSetId(attributeSetId string) ApiAttributeGroupListRequest {
	r.attributeSetId = &attributeSetId
	return r
}

func (r ApiAttributeGroupListRequest) Execute() (*ModelResponseAttributeGroupList, *http.Response, error) {
	return r.ApiService.AttributeGroupListExecute(r)
}

/*
AttributeGroupList attribute.group.list

Get attribute group list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeGroupListRequest
*/
func (a *AttributeAPIService) AttributeGroupList(ctx context.Context) ApiAttributeGroupListRequest {
	return ApiAttributeGroupListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseAttributeGroupList
func (a *AttributeAPIService) AttributeGroupListExecute(r ApiAttributeGroupListRequest) (*ModelResponseAttributeGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseAttributeGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeGroupList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.group.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,name"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.attributeSetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_set_id", r.attributeSetId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeInfoRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	id *string
	attributeSetId *string
	storeId *string
	langId *string
	params *string
	exclude *string
	responseFields *string
}

// Entity id
func (r ApiAttributeInfoRequest) Id(id string) ApiAttributeInfoRequest {
	r.id = &id
	return r
}

// Attribute set id
func (r ApiAttributeInfoRequest) AttributeSetId(attributeSetId string) ApiAttributeInfoRequest {
	r.attributeSetId = &attributeSetId
	return r
}

// Store Id
func (r ApiAttributeInfoRequest) StoreId(storeId string) ApiAttributeInfoRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiAttributeInfoRequest) LangId(langId string) ApiAttributeInfoRequest {
	r.langId = &langId
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiAttributeInfoRequest) Params(params string) ApiAttributeInfoRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiAttributeInfoRequest) Exclude(exclude string) ApiAttributeInfoRequest {
	r.exclude = &exclude
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiAttributeInfoRequest) ResponseFields(responseFields string) ApiAttributeInfoRequest {
	r.responseFields = &responseFields
	return r
}

func (r ApiAttributeInfoRequest) Execute() (*AttributeInfo200Response, *http.Response, error) {
	return r.ApiService.AttributeInfoExecute(r)
}

/*
AttributeInfo attribute.info

Get information about a specific global attribute by its ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeInfoRequest
*/
func (a *AttributeAPIService) AttributeInfo(ctx context.Context) ApiAttributeInfoRequest {
	return ApiAttributeInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeInfo200Response
func (a *AttributeAPIService) AttributeInfoExecute(r ApiAttributeInfoRequest) (*AttributeInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.info.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	if r.attributeSetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_set_id", r.attributeSetId, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "force_all"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeListRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	start *int32
	count *int32
	type_ *string
	attributeIds *string
	attributeSetId *string
	storeId *string
	langId *string
	params *string
	exclude *string
	responseFields *string
	visible *bool
	required *bool
	system *bool
}

// This parameter sets the number from which you want to get entities
func (r ApiAttributeListRequest) Start(start int32) ApiAttributeListRequest {
	r.start = &start
	return r
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiAttributeListRequest) Count(count int32) ApiAttributeListRequest {
	r.count = &count
	return r
}

// Defines attribute&#39;s type
func (r ApiAttributeListRequest) Type_(type_ string) ApiAttributeListRequest {
	r.type_ = &type_
	return r
}

// Filter attributes by ids
func (r ApiAttributeListRequest) AttributeIds(attributeIds string) ApiAttributeListRequest {
	r.attributeIds = &attributeIds
	return r
}

// Filter items by attribute set id
func (r ApiAttributeListRequest) AttributeSetId(attributeSetId string) ApiAttributeListRequest {
	r.attributeSetId = &attributeSetId
	return r
}

// Store Id
func (r ApiAttributeListRequest) StoreId(storeId string) ApiAttributeListRequest {
	r.storeId = &storeId
	return r
}

// Retrieves attributes on specified language id
func (r ApiAttributeListRequest) LangId(langId string) ApiAttributeListRequest {
	r.langId = &langId
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiAttributeListRequest) Params(params string) ApiAttributeListRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiAttributeListRequest) Exclude(exclude string) ApiAttributeListRequest {
	r.exclude = &exclude
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiAttributeListRequest) ResponseFields(responseFields string) ApiAttributeListRequest {
	r.responseFields = &responseFields
	return r
}

// Filter items by visibility status
func (r ApiAttributeListRequest) Visible(visible bool) ApiAttributeListRequest {
	r.visible = &visible
	return r
}

// Defines if the option is required
func (r ApiAttributeListRequest) Required(required bool) ApiAttributeListRequest {
	r.required = &required
	return r
}

// True if attribute is system
func (r ApiAttributeListRequest) System(system bool) ApiAttributeListRequest {
	r.system = &system
	return r
}

func (r ApiAttributeListRequest) Execute() (*ModelResponseAttributeList, *http.Response, error) {
	return r.ApiService.AttributeListExecute(r)
}

/*
AttributeList attribute.list

Get a list of global attributes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeListRequest
*/
func (a *AttributeAPIService) AttributeList(ctx context.Context) ApiAttributeListRequest {
	return ApiAttributeListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseAttributeList
func (a *AttributeAPIService) AttributeListExecute(r ApiAttributeListRequest) (*ModelResponseAttributeList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseAttributeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	} else {
		var defaultValue int32 = 0
		r.start = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.attributeIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_ids", r.attributeIds, "form", "")
	}
	if r.attributeSetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_set_id", r.attributeSetId, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "id,name,code,type"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.visible != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "visible", r.visible, "form", "")
	}
	if r.required != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "required", r.required, "form", "")
	}
	if r.system != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "system", r.system, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeTypeListRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
}

func (r ApiAttributeTypeListRequest) Execute() (*AttributeTypeList200Response, *http.Response, error) {
	return r.ApiService.AttributeTypeListExecute(r)
}

/*
AttributeTypeList attribute.type.list

Get list of supported attributes types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeTypeListRequest
*/
func (a *AttributeAPIService) AttributeTypeList(ctx context.Context) ApiAttributeTypeListRequest {
	return ApiAttributeTypeListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeTypeList200Response
func (a *AttributeAPIService) AttributeTypeListExecute(r ApiAttributeTypeListRequest) (*AttributeTypeList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeTypeList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeTypeList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.type.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeUnassignGroupRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	id *string
	groupId *string
}

// Entity id
func (r ApiAttributeUnassignGroupRequest) Id(id string) ApiAttributeUnassignGroupRequest {
	r.id = &id
	return r
}

// Customer group_id
func (r ApiAttributeUnassignGroupRequest) GroupId(groupId string) ApiAttributeUnassignGroupRequest {
	r.groupId = &groupId
	return r
}

func (r ApiAttributeUnassignGroupRequest) Execute() (*AttributeUnassignGroup200Response, *http.Response, error) {
	return r.ApiService.AttributeUnassignGroupExecute(r)
}

/*
AttributeUnassignGroup attribute.unassign.group

Unassign attribute from group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeUnassignGroupRequest
*/
func (a *AttributeAPIService) AttributeUnassignGroup(ctx context.Context) ApiAttributeUnassignGroupRequest {
	return ApiAttributeUnassignGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeUnassignGroup200Response
func (a *AttributeAPIService) AttributeUnassignGroupExecute(r ApiAttributeUnassignGroupRequest) (*AttributeUnassignGroup200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeUnassignGroup200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeUnassignGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.unassign.group.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.groupId == nil {
		return localVarReturnValue, nil, reportError("groupId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "group_id", r.groupId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeUnassignSetRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	id *string
	attributeSetId *string
}

// Entity id
func (r ApiAttributeUnassignSetRequest) Id(id string) ApiAttributeUnassignSetRequest {
	r.id = &id
	return r
}

// Attribute set id
func (r ApiAttributeUnassignSetRequest) AttributeSetId(attributeSetId string) ApiAttributeUnassignSetRequest {
	r.attributeSetId = &attributeSetId
	return r
}

func (r ApiAttributeUnassignSetRequest) Execute() (*AttributeUnassignGroup200Response, *http.Response, error) {
	return r.ApiService.AttributeUnassignSetExecute(r)
}

/*
AttributeUnassignSet attribute.unassign.set

Unassign attribute from attribute set

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeUnassignSetRequest
*/
func (a *AttributeAPIService) AttributeUnassignSet(ctx context.Context) ApiAttributeUnassignSetRequest {
	return ApiAttributeUnassignSetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeUnassignGroup200Response
func (a *AttributeAPIService) AttributeUnassignSetExecute(r ApiAttributeUnassignSetRequest) (*AttributeUnassignGroup200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeUnassignGroup200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeUnassignSet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.unassign.set.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.attributeSetId == nil {
		return localVarReturnValue, nil, reportError("attributeSetId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_set_id", r.attributeSetId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeUpdateRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	id *string
	name *string
	storeId *string
	langId *string
}

// Entity id
func (r ApiAttributeUpdateRequest) Id(id string) ApiAttributeUpdateRequest {
	r.id = &id
	return r
}

// Defines new attributes&#39;s name
func (r ApiAttributeUpdateRequest) Name(name string) ApiAttributeUpdateRequest {
	r.name = &name
	return r
}

// Store Id
func (r ApiAttributeUpdateRequest) StoreId(storeId string) ApiAttributeUpdateRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiAttributeUpdateRequest) LangId(langId string) ApiAttributeUpdateRequest {
	r.langId = &langId
	return r
}

func (r ApiAttributeUpdateRequest) Execute() (*AttributeUpdate200Response, *http.Response, error) {
	return r.ApiService.AttributeUpdateExecute(r)
}

/*
AttributeUpdate attribute.update

Update attribute data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeUpdateRequest
*/
func (a *AttributeAPIService) AttributeUpdate(ctx context.Context) ApiAttributeUpdateRequest {
	return ApiAttributeUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeUpdate200Response
func (a *AttributeAPIService) AttributeUpdateExecute(r ApiAttributeUpdateRequest) (*AttributeUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.update.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeValueAddRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	attributeId *string
	name *string
	code *string
	description *string
	storeId *string
	langId *string
}

// Attribute Id
func (r ApiAttributeValueAddRequest) AttributeId(attributeId string) ApiAttributeValueAddRequest {
	r.attributeId = &attributeId
	return r
}

// Defines attribute value&#39;s name
func (r ApiAttributeValueAddRequest) Name(name string) ApiAttributeValueAddRequest {
	r.name = &name
	return r
}

// Entity code
func (r ApiAttributeValueAddRequest) Code(code string) ApiAttributeValueAddRequest {
	r.code = &code
	return r
}

// Defines attribute value&#39;s description
func (r ApiAttributeValueAddRequest) Description(description string) ApiAttributeValueAddRequest {
	r.description = &description
	return r
}

// Store Id
func (r ApiAttributeValueAddRequest) StoreId(storeId string) ApiAttributeValueAddRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiAttributeValueAddRequest) LangId(langId string) ApiAttributeValueAddRequest {
	r.langId = &langId
	return r
}

func (r ApiAttributeValueAddRequest) Execute() (*AttributeAdd200Response, *http.Response, error) {
	return r.ApiService.AttributeValueAddExecute(r)
}

/*
AttributeValueAdd attribute.value.add

Add new value to attribute.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeValueAddRequest
*/
func (a *AttributeAPIService) AttributeValueAdd(ctx context.Context) ApiAttributeValueAddRequest {
	return ApiAttributeValueAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeAdd200Response
func (a *AttributeAPIService) AttributeValueAddExecute(r ApiAttributeValueAddRequest) (*AttributeAdd200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeAdd200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeValueAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.value.add.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.attributeId == nil {
		return localVarReturnValue, nil, reportError("attributeId is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_id", r.attributeId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeValueDeleteRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	id *string
	attributeId *string
	storeId *string
}

// Entity id
func (r ApiAttributeValueDeleteRequest) Id(id string) ApiAttributeValueDeleteRequest {
	r.id = &id
	return r
}

// Attribute Id
func (r ApiAttributeValueDeleteRequest) AttributeId(attributeId string) ApiAttributeValueDeleteRequest {
	r.attributeId = &attributeId
	return r
}

// Store Id
func (r ApiAttributeValueDeleteRequest) StoreId(storeId string) ApiAttributeValueDeleteRequest {
	r.storeId = &storeId
	return r
}

func (r ApiAttributeValueDeleteRequest) Execute() (*AttributeValueDelete200Response, *http.Response, error) {
	return r.ApiService.AttributeValueDeleteExecute(r)
}

/*
AttributeValueDelete attribute.value.delete

Delete attribute value.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeValueDeleteRequest
*/
func (a *AttributeAPIService) AttributeValueDelete(ctx context.Context) ApiAttributeValueDeleteRequest {
	return ApiAttributeValueDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeValueDelete200Response
func (a *AttributeAPIService) AttributeValueDeleteExecute(r ApiAttributeValueDeleteRequest) (*AttributeValueDelete200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeValueDelete200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeValueDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.value.delete.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.attributeId == nil {
		return localVarReturnValue, nil, reportError("attributeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_id", r.attributeId, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAttributeValueUpdateRequest struct {
	ctx context.Context
	ApiService *AttributeAPIService
	id *string
	attributeId *string
	name *string
	description *string
	code *string
	storeId *string
	langId *string
}

// Defines attribute value&#39;s id
func (r ApiAttributeValueUpdateRequest) Id(id string) ApiAttributeValueUpdateRequest {
	r.id = &id
	return r
}

// Attribute Id
func (r ApiAttributeValueUpdateRequest) AttributeId(attributeId string) ApiAttributeValueUpdateRequest {
	r.attributeId = &attributeId
	return r
}

// Defines attribute value&#39;s name
func (r ApiAttributeValueUpdateRequest) Name(name string) ApiAttributeValueUpdateRequest {
	r.name = &name
	return r
}

// Defines new attribute value&#39;s description
func (r ApiAttributeValueUpdateRequest) Description(description string) ApiAttributeValueUpdateRequest {
	r.description = &description
	return r
}

// Entity code
func (r ApiAttributeValueUpdateRequest) Code(code string) ApiAttributeValueUpdateRequest {
	r.code = &code
	return r
}

// Store Id
func (r ApiAttributeValueUpdateRequest) StoreId(storeId string) ApiAttributeValueUpdateRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiAttributeValueUpdateRequest) LangId(langId string) ApiAttributeValueUpdateRequest {
	r.langId = &langId
	return r
}

func (r ApiAttributeValueUpdateRequest) Execute() (*AttributeUpdate200Response, *http.Response, error) {
	return r.ApiService.AttributeValueUpdateExecute(r)
}

/*
AttributeValueUpdate attribute.value.update

Update attribute value.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAttributeValueUpdateRequest
*/
func (a *AttributeAPIService) AttributeValueUpdate(ctx context.Context) ApiAttributeValueUpdateRequest {
	return ApiAttributeValueUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeUpdate200Response
func (a *AttributeAPIService) AttributeValueUpdateExecute(r ApiAttributeValueUpdateRequest) (*AttributeUpdate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AttributeUpdate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AttributeAPIService.AttributeValueUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute.value.update.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.attributeId == nil {
		return localVarReturnValue, nil, reportError("attributeId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "attribute_id", r.attributeId, "form", "")
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.code != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "code", r.code, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
