/*
API2Cart OpenAPI

API2Cart

API version: 1.1
Contact: contact@api2cart.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// TaxAPIService TaxAPI service
type TaxAPIService service

type ApiTaxClassInfoRequest struct {
	ctx context.Context
	ApiService *TaxAPIService
	taxClassId *string
	storeId *string
	langId *string
	responseFields *string
	params *string
	exclude *string
}

// Retrieves taxes specified by class id
func (r ApiTaxClassInfoRequest) TaxClassId(taxClassId string) ApiTaxClassInfoRequest {
	r.taxClassId = &taxClassId
	return r
}

// Store Id
func (r ApiTaxClassInfoRequest) StoreId(storeId string) ApiTaxClassInfoRequest {
	r.storeId = &storeId
	return r
}

// Language id
func (r ApiTaxClassInfoRequest) LangId(langId string) ApiTaxClassInfoRequest {
	r.langId = &langId
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiTaxClassInfoRequest) ResponseFields(responseFields string) ApiTaxClassInfoRequest {
	r.responseFields = &responseFields
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiTaxClassInfoRequest) Params(params string) ApiTaxClassInfoRequest {
	r.params = &params
	return r
}

// Set this parameter in order to choose which entity fields you want to ignore. Works only if parameter &#x60;params&#x60; equal force_all
func (r ApiTaxClassInfoRequest) Exclude(exclude string) ApiTaxClassInfoRequest {
	r.exclude = &exclude
	return r
}

func (r ApiTaxClassInfoRequest) Execute() (*ModelResponseTaxClassInfo, *http.Response, error) {
	return r.ApiService.TaxClassInfoExecute(r)
}

/*
TaxClassInfo tax.class.info

Use this method to get information about a tax class and its rates. It allows you to calculate the tax percentage for a specific customer's address. This information contains relatively static data that rarely changes, so API2Cart may cache certain data to reduce the load on the store and speed up request execution. We also recommend that you cache the response of this method on your side to save requests. If you need to clear the cache for a specific store, use the cart.validate method.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTaxClassInfoRequest
*/
func (a *TaxAPIService) TaxClassInfo(ctx context.Context) ApiTaxClassInfoRequest {
	return ApiTaxClassInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseTaxClassInfo
func (a *TaxAPIService) TaxClassInfoExecute(r ApiTaxClassInfoRequest) (*ModelResponseTaxClassInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseTaxClassInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxAPIService.TaxClassInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tax.class.info.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.taxClassId == nil {
		return localVarReturnValue, nil, reportError("taxClassId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "tax_class_id", r.taxClassId, "form", "")
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.langId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lang_id", r.langId, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	} else {
		var defaultValue string = "tax_class_id,name,avail"
		r.params = &defaultValue
	}
	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaxClassListRequest struct {
	ctx context.Context
	ApiService *TaxAPIService
	count *int32
	pageCursor *string
	storeId *string
	findValue *string
	findWhere *string
	createdTo *string
	createdFrom *string
	modifiedTo *string
	modifiedFrom *string
	responseFields *string
}

// This parameter sets the entity amount that has to be retrieved. Max allowed count&#x3D;250
func (r ApiTaxClassListRequest) Count(count int32) ApiTaxClassListRequest {
	r.count = &count
	return r
}

// Used to retrieve entities via cursor-based pagination (it can&#39;t be used with any other filtering parameter)
func (r ApiTaxClassListRequest) PageCursor(pageCursor string) ApiTaxClassListRequest {
	r.pageCursor = &pageCursor
	return r
}

// Store Id
func (r ApiTaxClassListRequest) StoreId(storeId string) ApiTaxClassListRequest {
	r.storeId = &storeId
	return r
}

// Entity search that is specified by some value
func (r ApiTaxClassListRequest) FindValue(findValue string) ApiTaxClassListRequest {
	r.findValue = &findValue
	return r
}

// Tax class search that is specified by field
func (r ApiTaxClassListRequest) FindWhere(findWhere string) ApiTaxClassListRequest {
	r.findWhere = &findWhere
	return r
}

// Retrieve entities to their creation date
func (r ApiTaxClassListRequest) CreatedTo(createdTo string) ApiTaxClassListRequest {
	r.createdTo = &createdTo
	return r
}

// Retrieve entities from their creation date
func (r ApiTaxClassListRequest) CreatedFrom(createdFrom string) ApiTaxClassListRequest {
	r.createdFrom = &createdFrom
	return r
}

// Retrieve entities to their modification date
func (r ApiTaxClassListRequest) ModifiedTo(modifiedTo string) ApiTaxClassListRequest {
	r.modifiedTo = &modifiedTo
	return r
}

// Retrieve entities from their modification date
func (r ApiTaxClassListRequest) ModifiedFrom(modifiedFrom string) ApiTaxClassListRequest {
	r.modifiedFrom = &modifiedFrom
	return r
}

// Set this parameter in order to choose which entity fields you want to retrieve
func (r ApiTaxClassListRequest) ResponseFields(responseFields string) ApiTaxClassListRequest {
	r.responseFields = &responseFields
	return r
}

func (r ApiTaxClassListRequest) Execute() (*ModelResponseTaxClassList, *http.Response, error) {
	return r.ApiService.TaxClassListExecute(r)
}

/*
TaxClassList tax.class.list

Get list of tax classes from your store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTaxClassListRequest
*/
func (a *TaxAPIService) TaxClassList(ctx context.Context) ApiTaxClassListRequest {
	return ApiTaxClassListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelResponseTaxClassList
func (a *TaxAPIService) TaxClassListExecute(r ApiTaxClassListRequest) (*ModelResponseTaxClassList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelResponseTaxClassList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxAPIService.TaxClassList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tax.class.list.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.storeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "store_id", r.storeId, "form", "")
	}
	if r.findValue != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_value", r.findValue, "form", "")
	}
	if r.findWhere != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "find_where", r.findWhere, "form", "")
	}
	if r.createdTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_to", r.createdTo, "form", "")
	}
	if r.createdFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_from", r.createdFrom, "form", "")
	}
	if r.modifiedTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_to", r.modifiedTo, "form", "")
	}
	if r.modifiedFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "modified_from", r.modifiedFrom, "form", "")
	}
	if r.responseFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "response_fields", r.responseFields, "form", "")
	} else {
		var defaultValue string = "{return_code,return_message,pagination,result}"
		r.responseFields = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["StoreKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-store-key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
